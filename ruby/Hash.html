<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.42.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : Hash  -   Ruby 3.1.2 ' />
  <meta content="2022-06-09 20:39:28 -0700" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = false-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: Hash (Ruby 3.1.2) </title>
  <link rel="stylesheet" href="css/associated.css" type="text/css" >
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="css/carbon17.css" type="text/css" >


  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 


   
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

   <link rel="stylesheet" href="css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body id="top" class="class rdocstar">

<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'></ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 3.1.2 NOT FOUND -->
</div> <!-- end action bar -->
 <div class='wrapper'>
  
   <!-- carbon17 added here 2017-09-09 -->
 

   <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>hash.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Object.html">Object</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-5B-5D">::[]</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-ruby2_keywords_hash">::ruby2_keywords_hash</a></li>
          
          <li><a href="#method-c-ruby2_keywords_hash-3F">::ruby2_keywords_hash?</a></li>
          
          <li><a href="#method-c-try_convert">::try_convert</a></li>
          
          <li><a href="#method-i-3C">#<</a></li>
          
          <li><a href="#method-i-3C-3D">#<=</a></li>
          
          <li><a href="#method-i-3D-3D">#==</a></li>
          
          <li><a href="#method-i-3E">#></a></li>
          
          <li><a href="#method-i-3E-3D">#>=</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-any-3F">#any?</a></li>
          
          <li><a href="#method-i-assoc">#assoc</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-compact">#compact</a></li>
          
          <li><a href="#method-i-compact-21">#compact!</a></li>
          
          <li><a href="#method-i-compare_by_identity">#compare_by_identity</a></li>
          
          <li><a href="#method-i-compare_by_identity-3F">#compare_by_identity?</a></li>
          
          <li><a href="#method-i-deconstruct_keys">#deconstruct_keys</a></li>
          
          <li><a href="#method-i-default">#default</a></li>
          
          <li><a href="#method-i-default-3D">#default=</a></li>
          
          <li><a href="#method-i-default_proc">#default_proc</a></li>
          
          <li><a href="#method-i-default_proc-3D">#default_proc=</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_if">#delete_if</a></li>
          
          <li><a href="#method-i-dig">#dig</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_key">#each_key</a></li>
          
          <li><a href="#method-i-each_pair">#each_pair</a></li>
          
          <li><a href="#method-i-each_value">#each_value</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-eql-3F">#eql?</a></li>
          
          <li><a href="#method-i-except">#except</a></li>
          
          <li><a href="#method-i-fetch">#fetch</a></li>
          
          <li><a href="#method-i-fetch_values">#fetch_values</a></li>
          
          <li><a href="#method-i-filter">#filter</a></li>
          
          <li><a href="#method-i-filter-21">#filter!</a></li>
          
          <li><a href="#method-i-flatten">#flatten</a></li>
          
          <li><a href="#method-i-has_key-3F">#has_key?</a></li>
          
          <li><a href="#method-i-has_value-3F">#has_value?</a></li>
          
          <li><a href="#method-i-hash">#hash</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-initialize_copy">#initialize_copy</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-invert">#invert</a></li>
          
          <li><a href="#method-i-keep_if">#keep_if</a></li>
          
          <li><a href="#method-i-key">#key</a></li>
          
          <li><a href="#method-i-key-3F">#key?</a></li>
          
          <li><a href="#method-i-keys">#keys</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-member-3F">#member?</a></li>
          
          <li><a href="#method-i-merge">#merge</a></li>
          
          <li><a href="#method-i-merge-21">#merge!</a></li>
          
          <li><a href="#method-i-rassoc">#rassoc</a></li>
          
          <li><a href="#method-i-rehash">#rehash</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reject-21">#reject!</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-select-21">#select!</a></li>
          
          <li><a href="#method-i-shift">#shift</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-slice">#slice</a></li>
          
          <li><a href="#method-i-store">#store</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_h">#to_h</a></li>
          
          <li><a href="#method-i-to_hash">#to_hash</a></li>
          
          <li><a href="#method-i-to_proc">#to_proc</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-transform_keys">#transform_keys</a></li>
          
          <li><a href="#method-i-transform_keys-21">#transform_keys!</a></li>
          
          <li><a href="#method-i-transform_values">#transform_values</a></li>
          
          <li><a href="#method-i-transform_values-21">#transform_values!</a></li>
          
          <li><a href="#method-i-update">#update</a></li>
          
          <li><a href="#method-i-value-3F">#value?</a></li>
          
          <li><a href="#method-i-values">#values</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="Enumerable.html">Enumerable</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul id='files'>
        
          
          <li class="file"><a href="./_bundle/gems/minitest-5_15_0/History_rdoc.html">History.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/minitest-5_15_0/README_rdoc.html">README.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/History_rdoc.html">History.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/README_rdoc.html">README.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/doc/command_line_usage_rdoc.html">command_line_usage.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/doc/glossary_rdoc.html">glossary.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/doc/proto_rake_rdoc.html">proto_rake.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/doc/rakefile_rdoc.html">rakefile.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rake-13_0_6/doc/rational_rdoc.html">rational.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/context_rdoc.html">context.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/rdoc/child_rdoc.html">child.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/rdoc/document_rdoc.html">document.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/rdoc/element_rdoc.html">element.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/rdoc/node_rdoc.html">node.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/rdoc/parent_rdoc.html">parent.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/child_toc_rdoc.html">child_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/document_toc_rdoc.html">document_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/element_toc_rdoc.html">element_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/master_toc_rdoc.html">master_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/node_toc_rdoc.html">node_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_bundle/gems/rexml-3_2_5/doc/rexml/tasks/tocs/parent_toc_rdoc.html">parent_toc.rdoc</a></li>
        
          
          <li class="file"><a href="./_test/rdoc/test_ja_rdoc.html">test.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./COPYING_ja.html">COPYING.ja</a></li>
        
          
          <li class="file"><a href="./README_EXT.html">README.EXT</a></li>
        
          
          <li class="file"><a href="./README_EXT_ja.html">README.EXT.ja</a></li>
        
          
          <li class="file"><a href="./aclocal_m4.html">aclocal.m4</a></li>
        
          
          <li class="file"><a href="./autogen_sh.html">autogen.sh</a></li>
        
          
          <li class="file"><a href="./configure_ac.html">configure.ac</a></li>
        
          
          <li class="file"><a href="./doc/bsearch_rdoc.html">bsearch.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/bug_triaging_rdoc.html">bug_triaging.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/case_mapping_rdoc.html">case_mapping.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/contributing_rdoc.html">contributing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/arguments/io_rdoc.html">io.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/common/col_sep_rdoc.html">col_sep.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/common/quote_char_rdoc.html">quote_char.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/common/row_sep_rdoc.html">row_sep.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/force_quotes_rdoc.html">force_quotes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/quote_empty_rdoc.html">quote_empty.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/write_converters_rdoc.html">write_converters.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/write_empty_value_rdoc.html">write_empty_value.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/write_headers_rdoc.html">write_headers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/generating/write_nil_value_rdoc.html">write_nil_value.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/converters_rdoc.html">converters.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/empty_value_rdoc.html">empty_value.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/field_size_limit_rdoc.html">field_size_limit.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/header_converters_rdoc.html">header_converters.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/headers_rdoc.html">headers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/liberal_parsing_rdoc.html">liberal_parsing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/nil_value_rdoc.html">nil_value.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/return_headers_rdoc.html">return_headers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/skip_blanks_rdoc.html">skip_blanks.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/skip_lines_rdoc.html">skip_lines.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/strip_rdoc.html">strip.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/options/parsing/unconverted_fields_rdoc.html">unconverted_fields.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/recipes/filtering_rdoc.html">filtering.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/recipes/generating_rdoc.html">generating.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/recipes/parsing_rdoc.html">parsing.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/csv/recipes/recipes_rdoc.html">recipes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dig_methods_rdoc.html">dig_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/documentation_guide_rdoc.html">documentation_guide.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/dtrace_probes_rdoc.html">dtrace_probes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_ja_rdoc.html">extension.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/extension_rdoc.html">extension.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/globals_rdoc.html">globals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/implicit_conversion_rdoc.html">implicit_conversion.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/keywords_rdoc.html">keywords.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/maintainers_rdoc.html">maintainers.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/marshal_rdoc.html">marshal.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/optparse/argument_converters_rdoc.html">argument_converters.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/optparse/creates_option_rdoc.html">creates_option.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/optparse/option_params_rdoc.html">option_params.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/optparse/tutorial_rdoc.html">tutorial.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/regexp_rdoc.html">regexp.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/security_rdoc.html">security.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/signals_rdoc.html">signals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/standard_library_rdoc.html">standard_library.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax_rdoc.html">syntax.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/assignment_rdoc.html">assignment.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/calling_methods_rdoc.html">calling_methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/comments_rdoc.html">comments.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/control_expressions_rdoc.html">control_expressions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/exceptions_rdoc.html">exceptions.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/literals_rdoc.html">literals.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/methods_rdoc.html">methods.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/miscellaneous_rdoc.html">miscellaneous.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/modules_and_classes_rdoc.html">modules_and_classes.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/pattern_matching_rdoc.html">pattern_matching.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/precedence_rdoc.html">precedence.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/syntax/refinements_rdoc.html">refinements.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/in_rdoc.html">in.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/mon-min_rdoc.html">mon-min.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/msec_rdoc.html">msec.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/nsec_rdoc.html">nsec.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/sec_rdoc.html">sec.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/sec_i_rdoc.html">sec_i.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/usec_rdoc.html">usec.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/year_rdoc.html">year.rdoc</a></li>
        
          
          <li class="file"><a href="./doc/time/zone_and_in_rdoc.html">zone_and_in.rdoc</a></li>
        
          
          <li class="file"><a href="./lex_c_blt.html">lex.c.blt</a></li>
        
          
          <li class="file"><a href="./node_name_inc.html">node_name.inc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_ja_rdoc.html">README.ja.rdoc</a></li>
        
          
          <li class="file"><a href="./sample/drb/README_rdoc.html">README.rdoc</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./ARGF.html">ARGF</a></li>
        
          
          
          <li><a href="./ArgumentError.html">ArgumentError</a></li>
        
          
          
          <li><a href="./Array.html">Array</a></li>
        
          
          
          <li><a href="./BasicObject.html">BasicObject</a></li>
        
          
          
          <li><a href="./Binding.html">Binding</a></li>
        
          
          
          <li><a href="./Class.html">Class</a></li>
        
          
          
          <li><a href="./ClosedQueueError.html">ClosedQueueError</a></li>
        
          
          
          <li><a href="./Comparable.html">Comparable</a></li>
        
          
          
          <li><a href="./Complex.html">Complex</a></li>
        
          
          
          <li><a href="./Continuation.html">Continuation</a></li>
        
          
          
          <li><a href="./Dir.html">Dir</a></li>
        
          
          
          <li><a href="./ENV.html">ENV</a></li>
        
          
          
          <li><a href="./EOFError.html">EOFError</a></li>
        
          
          
          <li><a href="./Encoding.html">Encoding</a></li>
        
          
          
          <li><a href="./Encoding/CompatibilityError.html">Encoding::CompatibilityError</a></li>
        
          
          
          <li><a href="./Encoding/Converter.html">Encoding::Converter</a></li>
        
          
          
          <li><a href="./Encoding/ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a></li>
        
          
          
          <li><a href="./Encoding/InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a></li>
        
          
          
          <li><a href="./Encoding/UndefinedConversionError.html">Encoding::UndefinedConversionError</a></li>
        
          
          
          <li><a href="./EncodingError.html">EncodingError</a></li>
        
          
          
          <li><a href="./Enumerable.html">Enumerable</a></li>
        
          
          
          <li><a href="./Enumerator.html">Enumerator</a></li>
        
          
          
          <li><a href="./Enumerator/ArithmeticSequence.html">Enumerator::ArithmeticSequence</a></li>
        
          
          
          <li><a href="./Enumerator/Chain.html">Enumerator::Chain</a></li>
        
          
          
          <li><a href="./Enumerator/Generator.html">Enumerator::Generator</a></li>
        
          
          
          <li><a href="./Enumerator/Lazy.html">Enumerator::Lazy</a></li>
        
          
          
          <li><a href="./Enumerator/Producer.html">Enumerator::Producer</a></li>
        
          
          
          <li><a href="./Enumerator/Yielder.html">Enumerator::Yielder</a></li>
        
          
          
          <li><a href="./Errno.html">Errno</a></li>
        
          
          
          <li><a href="./Exception.html">Exception</a></li>
        
          
          
          <li><a href="./FalseClass.html">FalseClass</a></li>
        
          
          
          <li><a href="./Fiber.html">Fiber</a></li>
        
          
          
          <li><a href="./Fiber/SchedulerInterface.html">Fiber::SchedulerInterface</a></li>
        
          
          
          <li><a href="./FiberError.html">FiberError</a></li>
        
          
          
          <li><a href="./File.html">File</a></li>
        
          
          
          <li><a href="./File/File/Constants.html">File::File::Constants</a></li>
        
          
          
          <li><a href="./File/File/Constants.html">File::File::Constants</a></li>
        
          
          
          <li><a href="./File/Stat.html">File::Stat</a></li>
        
          
          
          <li><a href="./FileTest.html">FileTest</a></li>
        
          
          
          <li><a href="./Float.html">Float</a></li>
        
          
          
          <li><a href="./FloatDomainError.html">FloatDomainError</a></li>
        
          
          
          <li><a href="./FrozenError.html">FrozenError</a></li>
        
          
          
          <li><a href="./GC.html">GC</a></li>
        
          
          
          <li><a href="./GC/Profiler.html">GC::Profiler</a></li>
        
          
          
          <li><a href="./Hash.html">Hash</a></li>
        
          
          
          <li><a href="./IO.html">IO</a></li>
        
          
          
          <li><a href="./IO/Buffer.html">IO::Buffer</a></li>
        
          
          
          <li><a href="./IO/Buffer/AccessError.html">IO::Buffer::AccessError</a></li>
        
          
          
          <li><a href="./IO/Buffer/AllocationError.html">IO::Buffer::AllocationError</a></li>
        
          
          
          <li><a href="./IO/Buffer/InvalidatedError.html">IO::Buffer::InvalidatedError</a></li>
        
          
          
          <li><a href="./IO/Buffer/LockedError.html">IO::Buffer::LockedError</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitReadable.html">IO::EAGAINWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EAGAINWaitWritable.html">IO::EAGAINWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitReadable.html">IO::EINPROGRESSWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EINPROGRESSWaitWritable.html">IO::EINPROGRESSWaitWritable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitReadable.html">IO::EWOULDBLOCKWaitReadable</a></li>
        
          
          
          <li><a href="./IO/EWOULDBLOCKWaitWritable.html">IO::EWOULDBLOCKWaitWritable</a></li>
        
          
          
          <li><a href="./IO/WaitReadable.html">IO::WaitReadable</a></li>
        
          
          
          <li><a href="./IO/WaitWritable.html">IO::WaitWritable</a></li>
        
          
          
          <li><a href="./IOError.html">IOError</a></li>
        
          
          
          <li><a href="./IndexError.html">IndexError</a></li>
        
          
          
          <li><a href="./Integer.html">Integer</a></li>
        
          
          
          <li><a href="./Interrupt.html">Interrupt</a></li>
        
          
          
          <li><a href="./Kernel.html">Kernel</a></li>
        
          
          
          <li><a href="./KeyError.html">KeyError</a></li>
        
          
          
          <li><a href="./LoadError.html">LoadError</a></li>
        
          
          
          <li><a href="./LocalJumpError.html">LocalJumpError</a></li>
        
          
          
          <li><a href="./Marshal.html">Marshal</a></li>
        
          
          
          <li><a href="./MatchData.html">MatchData</a></li>
        
          
          
          <li><a href="./Math.html">Math</a></li>
        
          
          
          <li><a href="./Math/DomainError.html">Math::DomainError</a></li>
        
          
          
          <li><a href="./Method.html">Method</a></li>
        
          
          
          <li><a href="./Module.html">Module</a></li>
        
          
          
          <li><a href="./NameError.html">NameError</a></li>
        
          
          
          <li><a href="./NilClass.html">NilClass</a></li>
        
          
          
          <li><a href="./NoMatchingPatternError.html">NoMatchingPatternError</a></li>
        
          
          
          <li><a href="./NoMatchingPatternKeyError.html">NoMatchingPatternKeyError</a></li>
        
          
          
          <li><a href="./NoMemoryError.html">NoMemoryError</a></li>
        
          
          
          <li><a href="./NoMethodError.html">NoMethodError</a></li>
        
          
          
          <li><a href="./NotImplementedError.html">NotImplementedError</a></li>
        
          
          
          <li><a href="./Numeric.html">Numeric</a></li>
        
          
          
          <li><a href="./Object.html">Object</a></li>
        
          
          
          <li><a href="./ObjectSpace.html">ObjectSpace</a></li>
        
          
          
          <li><a href="./ObjectSpace/WeakMap.html">ObjectSpace::WeakMap</a></li>
        
          
          
          <li><a href="./Pool.html">Pool</a></li>
        
          
          
          <li><a href="./Proc.html">Proc</a></li>
        
          
          
          <li><a href="./Process.html">Process</a></li>
        
          
          
          <li><a href="./Process/GID.html">Process::GID</a></li>
        
          
          
          <li><a href="./Process/Status.html">Process::Status</a></li>
        
          
          
          <li><a href="./Process/Sys.html">Process::Sys</a></li>
        
          
          
          <li><a href="./Process/UID.html">Process::UID</a></li>
        
          
          
          <li><a href="./Ractor.html">Ractor</a></li>
        
          
          
          <li><a href="./Ractor/ClosedError.html">Ractor::ClosedError</a></li>
        
          
          
          <li><a href="./Ractor/Error.html">Ractor::Error</a></li>
        
          
          
          <li><a href="./Ractor/IsolationError.html">Ractor::IsolationError</a></li>
        
          
          
          <li><a href="./Ractor/MovedError.html">Ractor::MovedError</a></li>
        
          
          
          <li><a href="./Ractor/MovedObject.html">Ractor::MovedObject</a></li>
        
          
          
          <li><a href="./Ractor/RemoteError.html">Ractor::RemoteError</a></li>
        
          
          
          <li><a href="./Ractor/UnsafeError.html">Ractor::UnsafeError</a></li>
        
          
          
          <li><a href="./Random.html">Random</a></li>
        
          
          
          <li><a href="./Random/Formatter.html">Random::Formatter</a></li>
        
          
          
          <li><a href="./Range.html">Range</a></li>
        
          
          
          <li><a href="./RangeError.html">RangeError</a></li>
        
          
          
          <li><a href="./Rational.html">Rational</a></li>
        
          
          
          <li><a href="./Refinement.html">Refinement</a></li>
        
          
          
          <li><a href="./Regexp.html">Regexp</a></li>
        
          
          
          <li><a href="./RegexpError.html">RegexpError</a></li>
        
          
          
          <li><a href="./Ripper.html">Ripper</a></li>
        
          
          
          <li><a href="./RubyVM.html">RubyVM</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree.html">RubyVM::AbstractSyntaxTree</a></li>
        
          
          
          <li><a href="./RubyVM/AbstractSyntaxTree/Node.html">RubyVM::AbstractSyntaxTree::Node</a></li>
        
          
          
          <li><a href="./RubyVM/InstructionSequence.html">RubyVM::InstructionSequence</a></li>
        
          
          
          <li><a href="./RubyVM/MJIT.html">RubyVM::MJIT</a></li>
        
          
          
          <li><a href="./RubyVM/YJIT.html">RubyVM::YJIT</a></li>
        
          
          
          <li><a href="./RubyVM/YJIT/Block.html">RubyVM::YJIT::Block</a></li>
        
          
          
          <li><a href="./RubyVM/YJIT/Disasm.html">RubyVM::YJIT::Disasm</a></li>
        
          
          
          <li><a href="./RuntimeError.html">RuntimeError</a></li>
        
          
          
          <li><a href="./ScriptError.html">ScriptError</a></li>
        
          
          
          <li><a href="./SecurityError.html">SecurityError</a></li>
        
          
          
          <li><a href="./Signal.html">Signal</a></li>
        
          
          
          <li><a href="./SignalException.html">SignalException</a></li>
        
          
          
          <li><a href="./StandardError.html">StandardError</a></li>
        
          
          
          <li><a href="./StopIteration.html">StopIteration</a></li>
        
          
          
          <li><a href="./String.html">String</a></li>
        
          
          
          <li><a href="./Struct.html">Struct</a></li>
        
          
          
          <li><a href="./Symbol.html">Symbol</a></li>
        
          
          
          <li><a href="./SyntaxError.html">SyntaxError</a></li>
        
          
          
          <li><a href="./SystemCallError.html">SystemCallError</a></li>
        
          
          
          <li><a href="./SystemExit.html">SystemExit</a></li>
        
          
          
          <li><a href="./SystemStackError.html">SystemStackError</a></li>
        
          
          
          <li><a href="./Thread.html">Thread</a></li>
        
          
          
          <li><a href="./Thread/Backtrace.html">Thread::Backtrace</a></li>
        
          
          
          <li><a href="./Thread/Backtrace/Location.html">Thread::Backtrace::Location</a></li>
        
          
          
          <li><a href="./Thread/ConditionVariable.html">Thread::ConditionVariable</a></li>
        
          
          
          <li><a href="./Thread/Mutex.html">Thread::Mutex</a></li>
        
          
          
          <li><a href="./Thread/Queue.html">Thread::Queue</a></li>
        
          
          
          <li><a href="./Thread/SizedQueue.html">Thread::SizedQueue</a></li>
        
          
          
          <li><a href="./ThreadError.html">ThreadError</a></li>
        
          
          
          <li><a href="./ThreadGroup.html">ThreadGroup</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
          
          
          <li><a href="./TracePoint.html">TracePoint</a></li>
        
          
          
          <li><a href="./TrueClass.html">TrueClass</a></li>
        
          
          
          <li><a href="./TypeError.html">TypeError</a></li>
        
          
          
          <li><a href="./UnboundMethod.html">UnboundMethod</a></li>
        
          
          
          <li><a href="./UncaughtThrowError.html">UncaughtThrowError</a></li>
        
          
          
          <li><a href="./UnicodeNormalize.html">UnicodeNormalize</a></li>
        
          
          
          <li><a href="./Warning.html">Warning</a></li>
        
          
          
          <li><a href="./ZeroDivisionError.html">ZeroDivisionError</a></li>
        
          
          
          <li><a href="./fatal.html">fatal</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
  </div> 
  <div id="documentation">
    <h1 class="class">Hash</h1>

    <div id="description" class="description">
      
<p>A Hash maps each of its unique keys to a specific value.</p>

<p>A Hash has certain similarities to an Array, but:</p>
<ul><li>
<p>An Array index is always an Integer.</p>
</li><li>
<p>A Hash key can be (almost) any object.</p>
</li></ul>

<h3 id="class-Hash-label-Hash+Data+Syntax">Hash Data Syntax<span><a href="#class-Hash-label-Hash+Data+Syntax">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The older syntax for Hash data uses the “hash rocket,” <code>=&gt;</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">:foo</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">:baz</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Alternatively, but only for a Hash key that&#39;s a Symbol, you can use a newer JSON-style syntax, where each bareword becomes a Symbol:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>You can also use a String in place of a bareword:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">&#39;foo&#39;:</span> <span class="ruby-value">0</span>, <span class="ruby-value">&#39;bar&#39;:</span> <span class="ruby-value">1</span>, <span class="ruby-value">&#39;baz&#39;:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>And you can mix the styles:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>, <span class="ruby-value">&#39;baz&#39;:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>But it&#39;s an error to try the JSON-style syntax for a key that&#39;s not a bareword or a String:</p>

<pre># Raises SyntaxError (syntax error, unexpected &#39;:&#39;, expecting =&gt;):
h = {0: &#39;zero&#39;}</pre>

<p><a href="Hash.html"><code>Hash</code></a> value can be omitted, meaning that value will be fetched from the context by the name of the key:</p>

<pre>x = 0
y = 100
h = {x:, y:}
h # =&gt; {:x=&gt;0, :y=&gt;100}</pre>

<h3 id="class-Hash-label-Common+Uses">Common Uses<span><a href="#class-Hash-label-Common+Uses">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can use a Hash to give names to objects:</p>

<pre class="ruby"><span class="ruby-identifier">person</span> = {<span class="ruby-value">name:</span> <span class="ruby-string">&#39;Matz&#39;</span>, <span class="ruby-value">language:</span> <span class="ruby-string">&#39;Ruby&#39;</span>}
<span class="ruby-identifier">person</span> <span class="ruby-comment"># =&gt; {:name=&gt;&quot;Matz&quot;, :language=&gt;&quot;Ruby&quot;}</span>
</pre>

<p>You can use a Hash to give names to method arguments:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">some_method</span>(<span class="ruby-identifier">hash</span>)
  <span class="ruby-identifier">p</span> <span class="ruby-identifier">hash</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">some_method</span>({<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Note: when the last argument in a method call is a Hash, the curly braces may be omitted:</p>

<pre class="ruby"><span class="ruby-identifier">some_method</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>You can use a Hash to initialize an object:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Dev</span>
  <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:name</span>, <span class="ruby-value">:language</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">hash</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">hash</span>[<span class="ruby-value">:name</span>]
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">language</span> = <span class="ruby-identifier">hash</span>[<span class="ruby-value">:language</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">matz</span> = <span class="ruby-constant">Dev</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">name:</span> <span class="ruby-string">&#39;Matz&#39;</span>, <span class="ruby-value">language:</span> <span class="ruby-string">&#39;Ruby&#39;</span>)
<span class="ruby-identifier">matz</span> <span class="ruby-comment"># =&gt; #&lt;Dev: @name=&quot;Matz&quot;, @language=&quot;Ruby&quot;&gt;</span>
</pre>

<h3 id="class-Hash-label-Creating+a+Hash">Creating a Hash<span><a href="#class-Hash-label-Creating+a+Hash">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>You can create a Hash object explicitly with:</p>
<ul><li>
<p>A <a href="doc/syntax/literals_rdoc.html#label-Hash+Literals">hash literal</a>.</p>
</li></ul>

<p>You can convert certain objects to Hashes with:</p>
<ul><li>
<p>Method <a href="Kernel.html#method-i-Hash">Hash</a>.</p>
</li></ul>

<p>You can create a Hash by calling method <a href="Hash.html#method-c-new"><code>Hash.new</code></a>.</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Hash</span>
</pre>

<p>You can create a Hash by calling method <a href="Hash.html#method-c-5B-5D"><code>Hash.[]</code></a>.</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
</pre>

<p>Create a Hash with initial entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>You can create a Hash by using its literal form (curly braces).</p>

<p>Create an empty Hash:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {}</span>
</pre>

<p>Create a Hash with initial entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<h3 id="class-Hash-label-Hash+Value+Basics">Hash Value Basics<span><a href="#class-Hash-label-Hash+Value+Basics">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The simplest way to retrieve a Hash value (instance method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>The simplest way to create or update a Hash value (instance method <a href="Hash.html#method-i-5B-5D-3D"><code>[]=</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:bat</span>] = <span class="ruby-value">3</span> <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">4</span> <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;4, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>

<p>The simplest way to delete a Hash entry (instance method <a href="Hash.html#method-i-delete"><code>delete</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<h3 id="class-Hash-label-Entry+Order">Entry Order<span><a href="#class-Hash-label-Entry+Order">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>A Hash object presents its entries in the order of their creation. This is seen in:</p>
<ul><li>
<p>Iterative methods such as <code>each</code>, <code>each_key</code>, <code>each_pair</code>, <code>each_value</code>.</p>
</li><li>
<p>Other order-sensitive methods such as <code>shift</code>, <code>keys</code>, <code>values</code>.</p>
</li><li>
<p>The String returned by method <code>inspect</code>.</p>
</li></ul>

<p>A new Hash has its initial ordering per the given entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>[<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>]
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>New entries are added at the end:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Updating a value does not affect the order:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;3}</span>
</pre>

<p>But re-creating a deleted entry can affect the order:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:foo</span>)
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">5</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;3, :foo=&gt;5}</span>
</pre>

<h3 id="class-Hash-label-Hash+Keys">Hash Keys<span><a href="#class-Hash-label-Hash+Keys">&para;</a> <a href="#top">&uarr;</a></span></h3>

<h4 id="class-Hash-label-Hash+Key+Equivalence">Hash Key Equivalence<span><a href="#class-Hash-label-Hash+Key+Equivalence">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Two objects are treated as the same hash key when their <code>hash</code> value is identical and the two objects are <code>eql?</code> to each other.</p>

<h4 id="class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key<span><a href="#class-Hash-label-Modifying+an+Active+Hash+Key">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>Modifying a Hash key while it is in use damages the hash&#39;s index.</p>

<p>This Hash has keys that are Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span> = [ <span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span> ]
<span class="ruby-identifier">a1</span> = [ <span class="ruby-value">:baz</span>, <span class="ruby-value">:bat</span> ]
<span class="ruby-identifier">h</span> = {<span class="ruby-identifier">a0</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>, <span class="ruby-identifier">a1</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">a0</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; 110002110</span>
</pre>

<p>Modifying array element <code>a0[0]</code> changes its hash value:</p>

<pre class="ruby"><span class="ruby-identifier">a0</span>[<span class="ruby-value">0</span>] = <span class="ruby-value">:bam</span>
<span class="ruby-identifier">a0</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; 1069447059</span>
</pre>

<p>And damages the Hash index:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can repair the hash index using method <code>rehash</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">rehash</span> <span class="ruby-comment"># =&gt; {[:bam, :bar]=&gt;0, [:baz, :bat]=&gt;1}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-identifier">a0</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">a0</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>A String key is always safe. That&#39;s because an unfrozen String passed as a key will be replaced by a duplicated and frozen String:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span> = {<span class="ruby-identifier">s</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">first_key</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">first</span>
<span class="ruby-identifier">first_key</span>.<span class="ruby-identifier">frozen?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<h4 id="class-Hash-label-User-Defined+Hash+Keys">User-Defined Hash Keys<span><a href="#class-Hash-label-User-Defined+Hash+Keys">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>To be useable as a Hash key, objects must implement the methods <code>hash</code> and <code>eql?</code>. Note: this requirement does not apply if the Hash uses <a href="Hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a> since comparison will then rely on the keys&#39; object id instead of <code>hash</code> and <code>eql?</code>.</p>

<p>Object defines basic implementation for <code>hash</code> and <code>eq?</code> that makes each object a distinct key. Typically, user-defined classes will want to override these methods to provide meaningful behavior, or for example inherit Struct that has useful definitions for these.</p>

<p>A typical implementation of <code>hash</code> is based on the object&#39;s data while <code>eql?</code> is usually aliased to the overridden <code>==</code> method:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Book</span>
  <span class="ruby-identifier">attr_reader</span> <span class="ruby-value">:author</span>, <span class="ruby-value">:title</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">initialize</span>(<span class="ruby-identifier">author</span>, <span class="ruby-identifier">title</span>)
    <span class="ruby-ivar">@author</span> = <span class="ruby-identifier">author</span>
    <span class="ruby-ivar">@title</span> = <span class="ruby-identifier">title</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">==</span>(<span class="ruby-identifier">other</span>)
    <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">other</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">other</span>.<span class="ruby-identifier">author</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@author</span> <span class="ruby-operator">&amp;&amp;</span>
      <span class="ruby-identifier">other</span>.<span class="ruby-identifier">title</span> <span class="ruby-operator">==</span> <span class="ruby-ivar">@title</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-keyword">alias</span> <span class="ruby-identifier">eql?</span> <span class="ruby-identifier">==</span>

  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">hash</span>
    <span class="ruby-ivar">@author</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">^</span> <span class="ruby-ivar">@title</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># XOR</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">book1</span> = <span class="ruby-constant">Book</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&#39;matz&#39;</span>, <span class="ruby-string">&#39;Ruby in a Nutshell&#39;</span>
<span class="ruby-identifier">book2</span> = <span class="ruby-constant">Book</span>.<span class="ruby-identifier">new</span> <span class="ruby-string">&#39;matz&#39;</span>, <span class="ruby-string">&#39;Ruby in a Nutshell&#39;</span>

<span class="ruby-identifier">reviews</span> = {}

<span class="ruby-identifier">reviews</span>[<span class="ruby-identifier">book1</span>] = <span class="ruby-string">&#39;Great reference!&#39;</span>
<span class="ruby-identifier">reviews</span>[<span class="ruby-identifier">book2</span>] = <span class="ruby-string">&#39;Nice and compact!&#39;</span>

<span class="ruby-identifier">reviews</span>.<span class="ruby-identifier">length</span> <span class="ruby-comment">#=&gt; 1</span>
</pre>

<h3 id="class-Hash-label-Default+Values">Default Values<span><a href="#class-Hash-label-Default+Values">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The methods <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="Hash.html#method-i-values_at"><code>values_at</code></a> and <a href="Hash.html#method-i-dig"><code>dig</code></a> need to return the value associated to a certain key. When that key is not found, that value will be determined by its default proc (if any) or else its default (initially `nil`).</p>

<p>You can retrieve the default value with method <a href="Hash.html#method-i-default"><code>default</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can set the default value by passing an argument to method <a href="Hash.html#method-c-new"><code>Hash.new</code></a> or with method <a href="Hash.html#method-i-default-3D"><code>default=</code></a></p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">-1</span>)
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>This default value is returned for <a href="Hash.html#method-i-5B-5D"><code>[]</code></a>, <a href="Hash.html#method-i-values_at"><code>values_at</code></a> and <a href="Hash.html#method-i-dig"><code>dig</code></a> when a key is not found:</p>

<pre class="ruby"><span class="ruby-identifier">counts</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">42</span>}
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil (default)</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">42</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:bar</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">default</span> = <span class="ruby-value">0</span>
<span class="ruby-identifier">counts</span>[<span class="ruby-value">:bar</span>] <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>) <span class="ruby-comment"># =&gt; [42, 0, 0]</span>
<span class="ruby-identifier">counts</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>Note that the default value is used without being duplicated. It is not advised to set the default value to a mutable object:</p>

<pre class="ruby"><span class="ruby-identifier">synonyms</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>([])
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-comment"># =&gt; []</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:hi</span> <span class="ruby-comment"># =&gt; [:hi], but this mutates the default!</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; [:hi]</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:universe</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-comment"># =&gt; [:hi, :universe], oops</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [], oops</span>
</pre>

<p>To use a mutable object as default, it is recommended to use a default proc</p>

<h4 id="class-Hash-label-Default+Proc">Default Proc<span><a href="#class-Hash-label-Default+Proc">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>When the default proc for a Hash is set (i.e., not <code>nil</code>), the default value returned by method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> is determined by the default proc alone.</p>

<p>You can retrieve the default proc with method <a href="Hash.html#method-i-default_proc"><code>default_proc</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>You can set the default proc by calling <a href="Hash.html#method-c-new"><code>Hash.new</code></a> with a block or calling the method <a href="Hash.html#method-i-default_proc-3D"><code>default_proc=</code></a></p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key.inspect}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
</pre>

<p>When the default proc is set (i.e., not <code>nil</code>) and method <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> is called with with a non-existent key, <a href="Hash.html#method-i-5B-5D"><code>[]</code></a> calls the default proc with both the Hash object itself and the missing key, then returns the proc&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; &quot;Default value for nosuch&quot;</span>
</pre>

<p>Note that in the example above no entry for key <code>:nosuch</code> is created:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:nosuch</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>However, the proc itself can add a new entry:</p>

<pre class="ruby"><span class="ruby-identifier">synonyms</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">key</span>] = [] }
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-value">:hello</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:hello</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:hi</span> <span class="ruby-comment"># =&gt; [:hi]</span>
<span class="ruby-identifier">synonyms</span>[<span class="ruby-value">:world</span>] <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">:universe</span> <span class="ruby-comment"># =&gt; [:universe]</span>
<span class="ruby-identifier">synonyms</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [:hello, :world]</span>
</pre>

<p>Note that setting the default proc will clear the default value and vice versa.</p>

<h3 id="class-Hash-label-What-27s+Here">What&#39;s Here<span><a href="#class-Hash-label-What-27s+Here">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>First, what&#39;s elsewhere. Class Hash:</p>
<ul><li>
<p>Inherits from <a href="Object.html#class-Object-label-What-27s+Here">class Object</a>.</p>
</li><li>
<p>Includes <a href="Enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p>
</li></ul>

<p>Here, class Hash provides methods that are useful for:</p>
<ul><li>
<p><a href="#class-Hash-label-Methods+for+Creating+a+Hash">Creating a Hash</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Setting+Hash+State">Setting Hash State</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Querying">Querying</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Comparing">Comparing</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Fetching">Fetching</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Assigning">Assigning</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Deleting">Deleting</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Iterating">Iterating</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Converting">Converting</a></p>
</li><li>
<p><a href="#class-Hash-label-Methods+for+Transforming+Keys+and+Values">Transforming Keys and Values</a></p>
</li><li>
<p><a href="#class-Hash-label-Other+Methods">And more.…</a></p>
</li></ul>

<p>Class Hash also includes methods from module <a href="Enumerable.html"><code>Enumerable</code></a>.</p>

<h4 id="class-Hash-label-Methods+for+Creating+a+Hash">Methods for Creating a Hash<span><a href="#class-Hash-label-Methods+for+Creating+a+Hash">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-c-5B-5D"><code>::[]</code></a>
<dd>
<p>Returns a new hash populated with given objects.</p>
</dd><dt><a href="Hash.html#method-c-new"><code>::new</code></a>
<dd>
<p>Returns a new empty hash.</p>
</dd><dt><a href="Hash.html#method-c-try_convert"><code>::try_convert</code></a>
<dd>
<p>Returns a new hash created from a given object.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Setting+Hash+State">Methods for Setting Hash State<span><a href="#class-Hash-label-Methods+for+Setting+Hash+State">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a>
<dd>
<p>Sets <code>self</code> to consider only identity in comparing keys.</p>
</dd><dt><a href="Hash.html#method-i-default-3D"><code>default=</code></a>
<dd>
<p>Sets the default to a given value.</p>
</dd><dt><a href="Hash.html#method-i-default_proc-3D"><code>default_proc=</code></a>
<dd>
<p>Sets the default proc to a given proc.</p>
</dd><dt><a href="Hash.html#method-i-rehash"><code>rehash</code></a>
<dd>
<p>Rebuilds the hash table by recomputing the hash index for each key.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Querying">Methods for Querying<span><a href="#class-Hash-label-Methods+for+Querying">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-any-3F"><code>any?</code></a>
<dd>
<p>Returns whether any element satisfies a given criterion.</p>
</dd><dt><a href="Hash.html#method-i-compare_by_identity-3F"><code>compare_by_identity?</code></a>
<dd>
<p>Returns whether the hash considers only identity when comparing keys.</p>
</dd><dt><a href="Hash.html#method-i-default"><code>default</code></a>
<dd>
<p>Returns the default value, or the default value for a given key.</p>
</dd><dt><a href="Hash.html#method-i-default_proc"><code>default_proc</code></a>
<dd>
<p>Returns the default proc.</p>
</dd><dt><a href="Hash.html#method-i-empty-3F"><code>empty?</code></a>
<dd>
<p>Returns whether there are no entries.</p>
</dd><dt><a href="Hash.html#method-i-eql-3F"><code>eql?</code></a>
<dd>
<p>Returns whether a given object is equal to <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-hash"><code>hash</code></a>
<dd>
<p>Returns the integer hash code.</p>
</dd><dt><a href="Hash.html#method-i-has_value-3F"><code>has_value?</code></a>
<dd>
<p>Returns whether a given object is a value in <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-include-3F"><code>include?</code></a>, <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-member-3F"><code>member?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>
<dd>
<p>Returns whether a given object is a key in <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-length"><code>length</code></a>, <a href="Hash.html#method-i-size"><code>size</code></a>
<dd>
<p>Returns the count of entries.</p>
</dd><dt><a href="Hash.html#method-i-value-3F"><code>value?</code></a>
<dd>
<p>Returns whether a given object is a value in <code>self</code>.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Comparing">Methods for Comparing<span><a href="#class-Hash-label-Methods+for+Comparing">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="#method-i-3C">#<</a>
<dd>
<p>Returns whether <code>self</code> is a proper subset of a given object.</p>
</dd><dt><a href="#method-i-3C-3D">#<=</a>
<dd>
<p>Returns whether <code>self</code> is a subset of a given object.</p>
</dd><dt><a href="#method-i-3D-3D">#==</a>
<dd>
<p>Returns whether a given object is equal to <code>self</code>.</p>
</dd><dt><a href="#method-i-3E">#></a>
<dd>
<p>Returns whether <code>self</code> is a proper superset of a given object</p>
</dd><dt><a href="#method-i-3E-3D">#>=</a>
<dd>
<p>Returns whether <code>self</code> is a proper superset of a given object.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Fetching">Methods for Fetching<span><a href="#class-Hash-label-Methods+for+Fetching">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-5B-5D"><code>[]</code></a>
<dd>
<p>Returns the value associated with a given key.</p>
</dd><dt><a href="Hash.html#method-i-assoc"><code>assoc</code></a>
<dd>
<p>Returns a 2-element array containing a given key and its value.</p>
</dd><dt><a href="Hash.html#method-i-dig"><code>dig</code></a>
<dd>
<p>Returns the object in nested objects that is specified by a given key and additional arguments.</p>
</dd><dt><a href="Hash.html#method-i-fetch"><code>fetch</code></a>
<dd>
<p>Returns the value for a given key.</p>
</dd><dt><a href="Hash.html#method-i-fetch_values"><code>fetch_values</code></a>
<dd>
<p>Returns array containing the values associated with given keys.</p>
</dd><dt><a href="Hash.html#method-i-key"><code>key</code></a>
<dd>
<p>Returns the key for the first-found entry with a given value.</p>
</dd><dt><a href="Hash.html#method-i-keys"><code>keys</code></a>
<dd>
<p>Returns an array containing all keys in <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-rassoc"><code>rassoc</code></a>
<dd>
<p>Returns a 2-element array consisting of the key and value of the first-found entry having a given value.</p>
</dd><dt><a href="Hash.html#method-i-values"><code>values</code></a>
<dd>
<p>Returns an array containing all values in <code>self</code>/</p>
</dd><dt><a href="Hash.html#method-i-values_at"><code>values_at</code></a>
<dd>
<p>Returns an array containing values for given keys.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Assigning">Methods for Assigning<span><a href="#class-Hash-label-Methods+for+Assigning">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-5B-5D-3D"><code>[]=</code></a>, <a href="Hash.html#method-i-store"><code>store</code></a>
<dd>
<p>Associates a given key with a given value.</p>
</dd><dt><a href="Hash.html#method-i-merge"><code>merge</code></a>
<dd>
<p>Returns the hash formed by merging each given hash into a copy of <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-merge-21"><code>merge!</code></a>, <a href="Hash.html#method-i-update"><code>update</code></a>
<dd>
<p>Merges each given hash into <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-replace"><code>replace</code></a>
<dd>
<p>Replaces the entire contents of <code>self</code> with the contents of a givan hash.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Deleting">Methods for Deleting<span><a href="#class-Hash-label-Methods+for+Deleting">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>These methods remove entries from <code>self</code>:</p>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-clear"><code>clear</code></a>
<dd>
<p>Removes all entries from <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-compact-21"><code>compact!</code></a>
<dd>
<p>Removes all <code>nil</code>-valued entries from <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-delete"><code>delete</code></a>
<dd>
<p>Removes the entry for a given key.</p>
</dd><dt><a href="Hash.html#method-i-delete_if"><code>delete_if</code></a>
<dd>
<p>Removes entries selected by a given block.</p>
</dd><dt><a href="Hash.html#method-i-filter-21"><code>filter!</code></a>, <a href="Hash.html#method-i-select-21"><code>select!</code></a>
<dd>
<p>Keep only those entries selected by a given block.</p>
</dd><dt><a href="Hash.html#method-i-keep_if"><code>keep_if</code></a>
<dd>
<p>Keep only those entries selected by a given block.</p>
</dd><dt><a href="Hash.html#method-i-reject-21"><code>reject!</code></a>
<dd>
<p>Removes entries selected by a given block.</p>
</dd><dt><a href="Hash.html#method-i-shift"><code>shift</code></a>
<dd>
<p>Removes and returns the first entry.</p>
</dd></dl>

<p>These methods return a copy of <code>self</code> with some entries removed:</p>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-compact"><code>compact</code></a>
<dd>
<p>Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed.</p>
</dd><dt><a href="Hash.html#method-i-except"><code>except</code></a>
<dd>
<p>Returns a copy of <code>self</code> with entries removed for specified keys.</p>
</dd><dt><a href="Hash.html#method-i-filter"><code>filter</code></a>, <a href="Hash.html#method-i-select"><code>select</code></a>
<dd>
<p>Returns a copy of <code>self</code> with only those entries selected by a given block.</p>
</dd><dt><a href="Hash.html#method-i-reject"><code>reject</code></a>
<dd>
<p>Returns a copy of <code>self</code> with entries removed as specified by a given block.</p>
</dd><dt><a href="Hash.html#method-i-slice"><code>slice</code></a>
<dd>
<p>Returns a hash containing the entries for given keys.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Iterating">Methods for Iterating<span><a href="#class-Hash-label-Methods+for+Iterating">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-each"><code>each</code></a>, <a href="Hash.html#method-i-each_pair"><code>each_pair</code></a>
<dd>
<p>Calls a given block with each key-value pair.</p>
</dd><dt><a href="Hash.html#method-i-each_key"><code>each_key</code></a>
<dd>
<p>Calls a given block with each key.</p>
</dd><dt><a href="Hash.html#method-i-each_value"><code>each_value</code></a>
<dd>
<p>Calls a given block with each value.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Converting">Methods for Converting<span><a href="#class-Hash-label-Methods+for+Converting">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-inspect"><code>inspect</code></a>, <a href="Hash.html#method-i-to_s"><code>to_s</code></a>
<dd>
<p>Returns a new <a href="String.html"><code>String</code></a> containing the hash entries.</p>
</dd><dt><a href="Hash.html#method-i-to_a"><code>to_a</code></a>
<dd>
<p>Returns a new array of 2-element arrays; each nested array contains a key-value pair from <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-to_h"><code>to_h</code></a>
<dd>
<p>Returns <code>self</code> if a Hash; if a subclass of Hash, returns a Hash containing the entries from <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-to_hash"><code>to_hash</code></a>
<dd>
<p>Returns <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-to_proc"><code>to_proc</code></a>
<dd>
<p>Returns a proc that maps a given key to its value.</p>
</dd></dl>

<h4 id="class-Hash-label-Methods+for+Transforming+Keys+and+Values">Methods for Transforming Keys and Values<span><a href="#class-Hash-label-Methods+for+Transforming+Keys+and+Values">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-transform_keys"><code>transform_keys</code></a>
<dd>
<p>Returns a copy of <code>self</code> with modified keys.</p>
</dd><dt><a href="Hash.html#method-i-transform_keys-21"><code>transform_keys!</code></a>
<dd>
<p>Modifies keys in <code>self</code></p>
</dd><dt><a href="Hash.html#method-i-transform_values"><code>transform_values</code></a>
<dd>
<p>Returns a copy of <code>self</code> with modified values.</p>
</dd><dt><a href="Hash.html#method-i-transform_values-21"><code>transform_values!</code></a>
<dd>
<p>Modifies values in <code>self</code>.</p>
</dd></dl>

<h4 id="class-Hash-label-Other+Methods">Other Methods<span><a href="#class-Hash-label-Other+Methods">&para;</a> <a href="#top">&uarr;</a></span></h4>
<dl class="rdoc-list note-list"><dt><a href="Hash.html#method-i-flatten"><code>flatten</code></a>
<dd>
<p>Returns an array that is a 1-dimensional flattening of <code>self</code>.</p>
</dd><dt><a href="Hash.html#method-i-invert"><code>invert</code></a>
<dd>
<p>Returns a hash with the each key-value pair inverted.</p>
</dd></dl>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-c-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">Hash[] &rarr; new_empty_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Hash[hash] &rarr; new_hash</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Hash[ [*2_element_arrays] ] &rarr; new_hash</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">Hash[*objects] &rarr; new_hash</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object populated with the given objects, if any. See <a href="Hash.html#method-c-new"><code>Hash::new</code></a>.</p>

<p>With no argument, returns a new empty Hash.</p>

<p>When the single given argument is a Hash, returns a new Hash populated with the entries from the given Hash, excluding the default value or proc.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-constant">Hash</span>[<span class="ruby-identifier">h</span>] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>When the single given argument is an Array of 2-element Arrays, returns a new Hash object wherein each 2-element array forms a key-value entry:</p>

<pre class="ruby"><span class="ruby-constant">Hash</span>[ [ [<span class="ruby-value">:foo</span>, <span class="ruby-value">0</span>], [<span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>] ] ] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>When the argument count is an even number; returns a new Hash object wherein each successive pair of arguments has become a key-value entry:</p>

<pre class="ruby"><span class="ruby-constant">Hash</span>[<span class="ruby-value">:foo</span>, <span class="ruby-value">0</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Raises an exception if the argument list does not conform to any of the above.</p>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE hash, tmp;

    if (argc == 1) {
        tmp = rb_hash_s_try_convert(Qnil, argv[0]);
        if (!NIL_P(tmp)) {
            hash = hash_alloc(klass);
            hash_copy(hash, tmp);
            return hash;
        }

        tmp = rb_check_array_type(argv[0]);
        if (!NIL_P(tmp)) {
            long i;

            hash = hash_alloc(klass);
            for (i = 0; i &lt; RARRAY_LEN(tmp); ++i) {
                VALUE e = RARRAY_AREF(tmp, i);
                VALUE v = rb_check_array_type(e);
                VALUE key, val = Qnil;

                if (NIL_P(v)) {
                    rb_raise(rb_eArgError, &quot;wrong element type %s at %ld (expected array)&quot;,
                             rb_builtin_class_name(e), i);
                }
                switch (RARRAY_LEN(v)) {
                  default:
                    rb_raise(rb_eArgError, &quot;invalid number of elements (%ld for 1..2)&quot;,
                             RARRAY_LEN(v));
                  case 2:
                    val = RARRAY_AREF(v, 1);
                  case 1:
                    key = RARRAY_AREF(v, 0);
                    rb_hash_aset(hash, key, val);
                }
            }
            return hash;
        }
    }
    if (argc % 2 != 0) {
        rb_raise(rb_eArgError, &quot;odd number of arguments for Hash&quot;);
    }

    hash = hash_alloc(klass);
    rb_hash_bulk_insert(argc, argv, hash);
    hash_verify(hash);
    return hash;
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(default_value = nil) &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">new {|hash, key| ... } &rarr; new_hash</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new empty Hash object.</p>

<p>The initial default value and initial default proc for the new hash depend on which form above was used. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>

<p>If neither an argument nor a block given, initializes both the default value and the default proc to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If argument <code>default_value</code> given but no block given, initializes the default value to the given <code>default_value</code> and the default proc to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">false</span>)
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If a block given but no argument, stores the block as the default proc and sets the default value to <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; &quot;Default value for nosuch&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_initialize(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_hash_modify(hash);
    if (rb_block_given_p()) {
        rb_check_arity(argc, 0, 0);
        ifnone = rb_block_proc();
        SET_PROC_DEFAULT(hash, ifnone);
    }
    else {
        rb_check_arity(argc, 0, 1);
        ifnone = argc == 0 ? Qnil : argv[0];
        RHASH_SET_IFNONE(hash, ifnone);
    }

    return hash;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="ruby2_keywords_hash-method" class="method-detail ">
          <a name="method-c-ruby2_keywords_hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ruby2_keywords_hash(hash) &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Duplicates a given hash and adds a ruby2_keywords flag. This method is not for casual use; debugging, researching, and some truly necessary cases like deserialization of arguments.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">k:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">ruby2_keywords_hash</span>(<span class="ruby-identifier">h</span>)
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-value">k:</span> <span class="ruby-value">42</span>)
  <span class="ruby-identifier">k</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">foo</span>(<span class="ruby-operator">*</span>[<span class="ruby-identifier">h</span>]) <span class="ruby-comment">#=&gt; 1 with neither a warning or an error</span>
</pre>
            

            
            <div class="method-source-code" id="ruby2_keywords_hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_s_ruby2_keywords_hash(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    hash = rb_hash_dup(hash);
    RHASH(hash)-&gt;basic.flags |= RHASH_PASS_AS_KEYWORDS;
    return hash;
}
            </pre> 
            </div><!-- ruby2_keywords_hash-source -->
            
          </div>

          

          
        </div><!-- ruby2_keywords_hash-method -->
      
        <div id="ruby2_keywords_hash-3F-method" class="method-detail ">
          <a name="method-c-ruby2_keywords_hash-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ruby2_keywords_hash?(hash) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Checks if a given hash is flagged by <a href="Module.html#method-i-ruby2_keywords"><code>Module#ruby2_keywords</code></a> (or <a href="Proc.html#method-i-ruby2_keywords"><code>Proc#ruby2_keywords</code></a>). This method is not for casual use; debugging, researching, and some truly necessary cases like serialization of arguments.</p>

<pre class="ruby"><span class="ruby-identifier">ruby2_keywords</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">foo</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">ruby2_keywords_hash?</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">last</span>)
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">foo</span>(<span class="ruby-value">k:</span> <span class="ruby-value">1</span>)   <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">foo</span>({<span class="ruby-value">k:</span> <span class="ruby-value">1</span>}) <span class="ruby-comment">#=&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="ruby2_keywords_hash-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_s_ruby2_keywords_hash_p(VALUE dummy, VALUE hash)
{
    Check_Type(hash, T_HASH);
    return RBOOL(RHASH(hash)-&gt;basic.flags &amp; RHASH_PASS_AS_KEYWORDS);
}
            </pre> 
            </div><!-- ruby2_keywords_hash-3F-source -->
            
          </div>

          

          
        </div><!-- ruby2_keywords_hash-3F-method -->
      
        <div id="try_convert-method" class="method-detail ">
          <a name="method-c-try_convert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">try_convert(obj) &rarr; obj, new_hash, or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If <code>obj</code> is a Hash object, returns <code>obj</code>.</p>

<p>Otherwise if <code>obj</code> responds to <code>:to_hash</code>, calls <code>obj.to_hash</code> and returns the result.</p>

<p>Returns <code>nil</code> if <code>obj</code> does not respond to <code>:to_hash</code></p>

<p>Raises an exception unless <code>obj.to_hash</code> returns a Hash object.</p>
            

            
            <div class="method-source-code" id="try_convert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_s_try_convert(VALUE dummy, VALUE hash)
{
    return rb_check_hash_type(hash);
}
            </pre> 
            </div><!-- try_convert-source -->
            
          </div>

          

          
        </div><!-- try_convert-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="3C-method" class="method-detail ">
          <a name="method-i-3C"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash < other_hash &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>hash</code> is a proper subset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="3C-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_lt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}
            </pre> 
            </div><!-- 3C-source -->
            
          </div>

          

          
        </div><!-- 3C-method -->
      
        <div id="3C-3D-method" class="method-detail ">
          <a name="method-i-3C-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash <= other_hash &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>hash</code> is a subset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="3C-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_le(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &gt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(hash, other);
}
            </pre> 
            </div><!-- 3C-3D-source -->
            
          </div>

          

          
        </div><!-- 3C-3D-method -->
      
        <div id="3D-3D-method" class="method-detail ">
          <a name="method-i-3D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash == object &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if all of the following are true:</p>
<ul><li>
<p><code>object</code> is a Hash object.</p>
</li><li>
<p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p>
</li><li>
<p>For each key <code>key</code>, <code>hash[key] == object[key]</code>.</p>
</li></ul>

<p>Otherwise, returns <code>false</code>.</p>

<p>Equal:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h3</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="3D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_equal(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, FALSE);
}
            </pre> 
            </div><!-- 3D-3D-source -->
            
          </div>

          

          
        </div><!-- 3D-3D-method -->
      
        <div id="3E-method" class="method-detail ">
          <a name="method-i-3E"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash > other_hash &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>hash</code> is a proper superset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="3E-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_gt(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt;= RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}
            </pre> 
            </div><!-- 3E-source -->
            
          </div>

          

          
        </div><!-- 3E-method -->
      
        <div id="3E-3D-method" class="method-detail ">
          <a name="method-i-3E-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash >= other_hash &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <code>hash</code> is a superset of <code>other_hash</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h1</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="3E-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_ge(VALUE hash, VALUE other)
{
    other = to_hash(other);
    if (RHASH_SIZE(hash) &lt; RHASH_SIZE(other)) return Qfalse;
    return hash_le(other, hash);
}
            </pre> 
            </div><!-- 3E-3D-source -->
            
          </div>

          

          
        </div><!-- 3E-3D-method -->
      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash[key] &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value associated with the given <code>key</code>, if found:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>If <code>key</code> is not found, returns a default value (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:nosuch</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_aref(VALUE hash, VALUE key)
{
    st_data_t val;

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        return rb_hash_default_value(hash, key);
    }
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash[key] = value &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-store"><code>Hash#store</code></a> is an alias for <a href="Hash.html#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p>

<p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p>

<p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;2, :bar=&gt;3}</span>
</pre>

<p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="any-3F-method" class="method-detail ">
          <a name="method-i-any-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">any? &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">any?(object) &rarr; true or false</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">any? {|key, value| ... } &rarr; true or false</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if any element satisfies a given criterion; <code>false</code> otherwise.</p>

<p>With no argument and no block, returns <code>true</code> if <code>self</code> is non-empty; <code>false</code> if empty.</p>

<p>With argument <code>object</code> and no block, returns <code>true</code> if for any key <code>key</code> <code>h.assoc(key) == object</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:bar</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:bar</span>, <span class="ruby-value">0</span>]) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span>([<span class="ruby-value">:baz</span>, <span class="ruby-value">1</span>]) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>With no argument and a block, calls the block with each key-value pair; returns <code>true</code> if the block returns any truthy value, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">3</span> } <span class="ruby-comment"># =&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="any-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_any_p(int argc, VALUE *argv, VALUE hash)
{
    VALUE args[2];
    args[0] = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (RHASH_EMPTY_P(hash)) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn(&quot;given block not used&quot;);
        }
        args[1] = argv[0];

        rb_hash_foreach(hash, any_p_i_pattern, (VALUE)args);
    }
    else {
        if (!rb_block_given_p()) {
            /* yields pairs, never false */
            return Qtrue;
        }
        if (rb_block_pair_yield_optimizable())
            rb_hash_foreach(hash, any_p_i_fast, (VALUE)args);
        else
            rb_hash_foreach(hash, any_p_i, (VALUE)args);
    }
    return args[0];
}
            </pre> 
            </div><!-- any-3F-source -->
            
          </div>

          

          
        </div><!-- any-3F-method -->
      
        <div id="assoc-method" class="method-detail ">
          <a name="method-i-assoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">assoc(key) &rarr; new_array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>If the given <code>key</code> is found, returns a 2-element Array containing that key and its value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">assoc</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; [:bar, 1]</span>
</pre>

<p>Returns <code>nil</code> if key <code>key</code> is not found.</p>
            

            
            <div class="method-source-code" id="assoc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_assoc(VALUE hash, VALUE key)
{
    st_table *table;
    const struct st_hash_type *orighash;
    VALUE args[2];

    if (RHASH_EMPTY_P(hash)) return Qnil;

    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));
    table = RHASH_ST_TABLE(hash);
    orighash = table-&gt;type;

    if (orighash != &amp;identhash) {
        VALUE value;
        struct reset_hash_type_arg ensure_arg;
        struct st_hash_type assochash;

        assochash.compare = assoc_cmp;
        assochash.hash = orighash-&gt;hash;
        table-&gt;type = &amp;assochash;
        args[0] = hash;
        args[1] = key;
        ensure_arg.hash = hash;
        ensure_arg.orighash = orighash;
        value = rb_ensure(lookup2_call, (VALUE)&amp;args, reset_hash_type, (VALUE)&amp;ensure_arg);
        if (value != Qundef) return rb_assoc_new(key, value);
    }

    args[0] = key;
    args[1] = Qnil;
    rb_hash_foreach(hash, assoc_i, (VALUE)args);
    return args[1];
}
            </pre> 
            </div><!-- assoc-source -->
            
          </div>

          

          
        </div><!-- assoc-method -->
      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes all hash entries; returns <code>self</code>.</p>
            

            
            <div class="method-source-code" id="clear-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_clear(VALUE hash)
{
    rb_hash_modify_check(hash);

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_hash_foreach(hash, clear_i, 0);
    }
    else if (RHASH_AR_TABLE_P(hash)) {
        ar_clear(hash);
    }
    else {
        st_clear(RHASH_ST_TABLE(hash));
    }

    return hash;
}
            </pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->
      
        <div id="compact-method" class="method-detail ">
          <a name="method-i-compact"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a copy of <code>self</code> with all <code>nil</code>-valued entries removed:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bat:</span> <span class="ruby-keyword">nil</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">compact</span>
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="compact-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_compact(VALUE hash)
{
    VALUE result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(hash, set_if_not_nil, result);
    }
    return result;
}
            </pre> 
            </div><!-- compact-source -->
            
          </div>

          

          
        </div><!-- compact-method -->
      
        <div id="compact-21-method" class="method-detail ">
          <a name="method-i-compact-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compact! &rarr; self or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code> with all its <code>nil</code>-valued entries removed (in place):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-keyword">nil</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bat:</span> <span class="ruby-keyword">nil</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compact!</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>
            

            
            <div class="method-source-code" id="compact-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_compact_bang(VALUE hash)
{
    st_index_t n;
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (n) {
        rb_hash_foreach(hash, delete_if_nil, hash);
        if (n != RHASH_SIZE(hash))
            return hash;
    }
    return Qnil;
}
            </pre> 
            </div><!-- compact-21-source -->
            
          </div>

          

          
        </div><!-- compact-21-method -->
      
        <div id="compare_by_identity-method" class="method-detail ">
          <a name="method-i-compare_by_identity"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compare_by_identity &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets <code>self</code> to consider only identity in comparing keys; two keys are considered the same only if they are the same object; returns <code>self</code>.</p>

<p>By default, these two object are considered to be the same key, so <code>s1</code> will overwrite <code>s0</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s0</span> = <span class="ruby-string">&#39;x&#39;</span>
<span class="ruby-identifier">s1</span> = <span class="ruby-string">&#39;x&#39;</span>
<span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s0</span>] = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s1</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;x&quot;=&gt;1}</span>
</pre>

<p>After calling #compare_by_identity, the keys are considered to be different, and therefore do not overwrite each other:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity</span> <span class="ruby-comment"># =&gt; {}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">compare_by_identity?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s0</span>] = <span class="ruby-value">0</span>
<span class="ruby-identifier">h</span>[<span class="ruby-identifier">s1</span>] = <span class="ruby-value">1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {&quot;x&quot;=&gt;0, &quot;x&quot;=&gt;1}</span>
</pre>
            

            
            <div class="method-source-code" id="compare_by_identity-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_compare_by_id(VALUE hash)
{
    VALUE tmp;
    st_table *identtable;

    if (rb_hash_compare_by_id_p(hash)) return hash;

    rb_hash_modify_check(hash);
    ar_force_convert_table(hash, __FILE__, __LINE__);
    HASH_ASSERT(RHASH_ST_TABLE_P(hash));

    tmp = hash_alloc(0);
    identtable = rb_init_identtable_with_size(RHASH_SIZE(hash));
    RHASH_ST_TABLE_SET(tmp, identtable);
    rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
    st_free_table(RHASH_ST_TABLE(hash));
    RHASH_ST_TABLE_SET(hash, identtable);
    RHASH_ST_CLEAR(tmp);

    return hash;
}
            </pre> 
            </div><!-- compare_by_identity-source -->
            
          </div>

          

          
        </div><!-- compare_by_identity-method -->
      
        <div id="compare_by_identity-3F-method" class="method-detail ">
          <a name="method-i-compare_by_identity-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">compare_by_identity? &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if <a href="Hash.html#method-i-compare_by_identity"><code>compare_by_identity</code></a> has been called, <code>false</code> otherwise.</p>
            

            
            <div class="method-source-code" id="compare_by_identity-3F-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_compare_by_id_p(VALUE hash)
{
    return RBOOL(RHASH_ST_TABLE_P(hash) &amp;&amp; RHASH_ST_TABLE(hash)-&gt;type == &amp;identhash);
}
            </pre> 
            </div><!-- compare_by_identity-3F-source -->
            
          </div>

          

          
        </div><!-- compare_by_identity-3F-method -->
      
        <div id="deconstruct_keys-method" class="method-detail ">
          <a name="method-i-deconstruct_keys"></a>

          
          <div class="method-heading">
            <span class="method-name">deconstruct_keys</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
            <div class="method-source-code" id="deconstruct_keys-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_deconstruct_keys(VALUE hash, VALUE keys)
{
    return hash;
}
            </pre> 
            </div><!-- deconstruct_keys-source -->
            
          </div>

          

          
        </div><!-- deconstruct_keys-method -->
      
        <div id="default-method" class="method-detail ">
          <a name="method-i-default"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">default &rarr; object</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">default(key) &rarr; object</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the default value for the given <code>key</code>. The returned value will be determined either by the default proc or by the default value. See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>

<p>With no argument, returns the current default value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>key</code> is given, returns the default value for <code>key</code>, regardless of whether that key exists:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">hash</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-node">&quot;No key #{key}&quot;</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-string">&quot;Hello&quot;</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; &quot;No key foo&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="default-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_default(int argc, VALUE *argv, VALUE hash)
{
    VALUE ifnone;

    rb_check_arity(argc, 0, 1);
    ifnone = RHASH_IFNONE(hash);
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        if (argc == 0) return Qnil;
        return call_default_proc(ifnone, hash, argv[0]);
    }
    return ifnone;
}
            </pre> 
            </div><!-- default-source -->
            
          </div>

          

          
        </div><!-- default-method -->
      
        <div id="default-3D-method" class="method-detail ">
          <a name="method-i-default-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">default = value &rarr; object</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the default value to <code>value</code>; returns <code>value</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> = <span class="ruby-keyword">false</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>See <a href="#class-Hash-label-Default+Values">Default Values</a>.</p>
            

            
            <div class="method-source-code" id="default-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_set_default(VALUE hash, VALUE ifnone)
{
    rb_hash_modify_check(hash);
    SET_DEFAULT(hash, ifnone);
    return ifnone;
}
            </pre> 
            </div><!-- default-3D-source -->
            
          </div>

          

          
        </div><!-- default-3D-method -->
      
        <div id="default_proc-method" class="method-detail ">
          <a name="method-i-default_proc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">default_proc &rarr; proc or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the default proc for <code>self</code> (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
</pre>
            

            
            <div class="method-source-code" id="default_proc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_default_proc(VALUE hash)
{
    if (FL_TEST(hash, RHASH_PROC_DEFAULT)) {
        return RHASH_IFNONE(hash);
    }
    return Qnil;
}
            </pre> 
            </div><!-- default_proc-source -->
            
          </div>

          

          
        </div><!-- default_proc-method -->
      
        <div id="default_proc-3D-method" class="method-detail ">
          <a name="method-i-default_proc-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">default_proc = proc &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the default proc for <code>self</code> to <code>proc</code>: (see <a href="#class-Hash-label-Default+Values">Default Values</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-identifier">proc</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Default value for #{key}&quot;</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-keyword">nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="default_proc-3D-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_set_default_proc(VALUE hash, VALUE proc)
{
    VALUE b;

    rb_hash_modify_check(hash);
    if (NIL_P(proc)) {
        SET_DEFAULT(hash, proc);
        return proc;
    }
    b = rb_check_convert_type_with_id(proc, T_DATA, &quot;Proc&quot;, idTo_proc);
    if (NIL_P(b) || !rb_obj_is_proc(b)) {
        rb_raise(rb_eTypeError,
                 &quot;wrong default_proc type %s (expected Proc)&quot;,
                 rb_obj_classname(proc));
    }
    proc = b;
    SET_PROC_DEFAULT(hash, proc);
    return proc;
}
            </pre> 
            </div><!-- default_proc-3D-source -->
            
          </div>

          

          
        </div><!-- default_proc-3D-method -->
      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete(key) &rarr; value or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete(key) {|key| ... } &rarr; object</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes the entry for the given <code>key</code> and returns its associated value.</p>

<p>If no block is given and <code>key</code> is found, deletes the entry and returns the associated value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :baz=&gt;2}</span>
</pre>

<p>If no block given and <code>key</code> is not found, returns <code>nil</code>.</p>

<p>If a block is given and <code>key</code> is found, ignores the block, deletes the entry, and returns the associated value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:baz</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Will never happen&#39;</span>} <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>If a block is given and <code>key</code> is not found, calls the block and returns the block&#39;s return value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-value">:nosuch</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;Key #{key} not found&quot;</span> } <span class="ruby-comment"># =&gt; &quot;Key nosuch not found&quot;</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="delete-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_delete_m(VALUE hash, VALUE key)
{
    VALUE val;

    rb_hash_modify_check(hash);
    val = rb_hash_delete_entry(hash, key);

    if (val != Qundef) {
        return val;
    }
    else {
        if (rb_block_given_p()) {
            return rb_yield(key);
        }
        else {
            return Qnil;
        }
    }
}
            </pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->
      
        <div id="delete_if-method" class="method-detail ">
          <a name="method-i-delete_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_if {|key, value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">delete_if &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>If a block given, calls the block with each key-value pair; deletes each entry for which the block returns a truthy value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete_if</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

<p>If no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">delete_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:delete_if&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>
            

            
            <div class="method-source-code" id="delete_if-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_delete_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, delete_if_i, hash);
    }
    return hash;
}
            </pre> 
            </div><!-- delete_if-source -->
            
          </div>

          

          
        </div><!-- delete_if-method -->
      
        <div id="dig-method" class="method-detail ">
          <a name="method-i-dig"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">dig(key, *identifiers) &rarr; object</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Finds and returns the object in nested objects that is specified by <code>key</code> and <code>identifiers</code>. The nested objects may be instances of various classes. See Dig Methods.</p>

<p>Nested Hashes:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; {:bar=&gt;{:baz=&gt;2}}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; {:baz=&gt;2}</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:baz</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">:BAZ</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Nested Hashes and Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> [<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>, <span class="ruby-value">:c</span>]}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :c</span>
</pre>

<p>This method will use the <a href="#class-Hash-label-Default+Values">default values</a> for keys that are not present:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> {<span class="ruby-value">bar:</span> [<span class="ruby-value">:a</span>, <span class="ruby-value">:b</span>, <span class="ruby-value">:c</span>]}}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">default_proc</span> = <span class="ruby-operator">-&gt;</span> (<span class="ruby-identifier">hash</span>, <span class="ruby-identifier">_key</span>) { <span class="ruby-identifier">hash</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:world</span>) <span class="ruby-comment"># =&gt; h</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">dig</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:world</span>, <span class="ruby-value">:foo</span>, <span class="ruby-value">:bar</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :c</span>
</pre>
            

            
            <div class="method-source-code" id="dig-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_hash_aref(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}
            </pre> 
            </div><!-- dig-source -->
            
          </div>

          

          
        </div><!-- dig-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each {|key, value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_pair {|key, value| ... } &rarr; self</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each &rarr; new_enumerator</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_pair &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-each"><code>Hash#each</code></a> is an alias for <a href="Hash.html#method-i-each_pair"><code>Hash#each_pair</code></a>.</p>

<p>Calls the given block with each key-value pair; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_pair_yield_optimizable())
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_key-method" class="method-detail ">
          <a name="method-i-each_key"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_key {|key| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_key &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block with each key; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_key</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">key</span> }  <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
<span class="ruby-identifier">baz</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_key</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_key&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">key</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">foo</span>
<span class="ruby-identifier">bar</span>
<span class="ruby-identifier">baz</span>
</pre>
            

            
            <div class="method-source-code" id="each_key-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_each_key(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_key_i, 0);
    return hash;
}
            </pre> 
            </div><!-- each_key-source -->
            
          </div>

          

          
        </div><!-- each_key-method -->
      
        <div id="each_pair-method" class="method-detail ">
          <a name="method-i-each_pair"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_pair {|key, value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_pair &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-each"><code>Hash#each</code></a> is an alias for <a href="Hash.html#method-i-each_pair"><code>Hash#each_pair</code></a>.</p>

<p>Calls the given block with each key-value pair; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_pair&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;#{key}: #{value}&quot;</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre>foo: 0
bar: 1
baz: 2</pre>
            

            
            <div class="method-source-code" id="each_pair-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_each_pair(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    if (rb_block_pair_yield_optimizable())
        rb_hash_foreach(hash, each_pair_i_fast, 0);
    else
        rb_hash_foreach(hash, each_pair_i, 0);
    return hash;
}
            </pre> 
            </div><!-- each_pair-source -->
            
          </div>

          

          
        </div><!-- each_pair-method -->
      
        <div id="each_value-method" class="method-detail ">
          <a name="method-i-each_value"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_value {|value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">each_value &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the given block with each value; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_value</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">value</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
<span class="ruby-value">2</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">each_value</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:each_value&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">puts</span> <span class="ruby-identifier">value</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-value">0</span>
<span class="ruby-value">1</span>
<span class="ruby-value">2</span>
</pre>
            

            
            <div class="method-source-code" id="each_value-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_each_value(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_foreach(hash, each_value_i, 0);
    return hash;
}
            </pre> 
            </div><!-- each_value-source -->
            
          </div>

          

          
        </div><!-- each_value-method -->
      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty? &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if there are no hash entries, <code>false</code> otherwise:</p>

<pre class="ruby">{}.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; true</span>
{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_empty_p(VALUE hash)
{
    return RBOOL(RHASH_EMPTY_P(hash));
}
            </pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->
      
        <div id="eql-3F-method" class="method-detail ">
          <a name="method-i-eql-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">eql? object &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>true</code> if all of the following are true:</p>
<ul><li>
<p><code>object</code> is a Hash object.</p>
</li><li>
<p><code>hash</code> and <code>object</code> have the same keys (regardless of order).</p>
</li><li>
<p>For each key <code>key</code>, <code>h[key] eql? object[key]</code>.</p>
</li></ul>

<p>Otherwise, returns <code>false</code>.</p>

<p>Equal:</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h2</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h3</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h1</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="eql-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_eql(VALUE hash1, VALUE hash2)
{
    return hash_equal(hash1, hash2, TRUE);
}
            </pre> 
            </div><!-- eql-3F-source -->
            
          </div>

          

          
        </div><!-- eql-3F-method -->
      
        <div id="except-method" class="method-detail ">
          <a name="method-i-except"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">except(*keys) &rarr; a_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash excluding entries for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = { <span class="ruby-value">a:</span> <span class="ruby-value">100</span>, <span class="ruby-value">b:</span> <span class="ruby-value">200</span>, <span class="ruby-value">c:</span> <span class="ruby-value">300</span> }
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">except</span>(<span class="ruby-value">:a</span>)          <span class="ruby-comment">#=&gt; {:b=&gt;200, :c=&gt;300}</span>
</pre>

<p>Any given <code>keys</code> that are not found are ignored.</p>
            

            
            <div class="method-source-code" id="except-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_except(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, result;

    result = hash_dup_with_compare_by_id(hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        rb_hash_delete(result, key);
    }

    return result;
}
            </pre> 
            </div><!-- except-source -->
            
          </div>

          

          
        </div><!-- except-method -->
      
        <div id="fetch-method" class="method-detail ">
          <a name="method-i-fetch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch(key) &rarr; object</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(key, default_value) &rarr; object</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch(key) {|key| ... } &rarr; object</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the value for the given <code>key</code>, if found.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>If <code>key</code> is not found and no block was given, returns <code>default_value</code>:</p>

<pre class="ruby">{}.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:nosuch</span>, <span class="ruby-value">:default</span>) <span class="ruby-comment"># =&gt; :default</span>
</pre>

<p>If <code>key</code> is not found and a block was given, yields <code>key</code> to the block and returns the block&#39;s return value:</p>

<pre class="ruby">{}.<span class="ruby-identifier">fetch</span>(<span class="ruby-value">:nosuch</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;No key #{key}&quot;</span>} <span class="ruby-comment"># =&gt; &quot;No key nosuch&quot;</span>
</pre>

<p>Raises <a href="KeyError.html"><code>KeyError</code></a> if neither <code>default_value</code> nor a block was given.</p>

<p>Note that this method does not use the values of either <a href="Hash.html#method-i-default"><code>default</code></a> or <a href="Hash.html#method-i-default_proc"><code>default_proc</code></a>.</p>
            

            
            <div class="method-source-code" id="fetch-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_fetch_m(int argc, VALUE *argv, VALUE hash)
{
    VALUE key;
    st_data_t val;
    long block_given;

    rb_check_arity(argc, 1, 2);
    key = argv[0];

    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }

    if (hash_stlike_lookup(hash, key, &amp;val)) {
        return (VALUE)val;
    }
    else {
        if (block_given) {
            return rb_yield(key);
        }
        else if (argc == 1) {
            VALUE desc = rb_protect(rb_inspect, key, 0);
            if (NIL_P(desc)) {
                desc = rb_any_to_s(key);
            }
            desc = rb_str_ellipsize(desc, 65);
            rb_key_err_raise(rb_sprintf(&quot;key not found: %&quot;PRIsVALUE, desc), hash, key);
        }
        else {
            return argv[1];
        }
    }
}
            </pre> 
            </div><!-- fetch-source -->
            
          </div>

          

          
        </div><!-- fetch-method -->
      
        <div id="fetch_values-method" class="method-detail ">
          <a name="method-i-fetch_values"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch_values(*keys) &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">fetch_values(*keys) {|key| ... } &rarr; new_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array containing the values associated with the given keys *keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [2, 0]</span>
</pre>

<p>Returns a new empty Array if no arguments given.</p>

<p>When a block is given, calls the block with each missing key, treating the block&#39;s return value as the value for that key:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">values</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">fetch_values</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">:foo</span>, <span class="ruby-value">:bad</span>, <span class="ruby-value">:bam</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span>}
<span class="ruby-identifier">values</span> <span class="ruby-comment"># =&gt; [1, 0, &quot;bad&quot;, &quot;bam&quot;]</span>
</pre>

<p>When no block is given, raises an exception if any given key is not found.</p>
            

            
            <div class="method-source-code" id="fetch_values-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_fetch_values(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_fetch(hash, argv[i]));
    }
    return result;
}
            </pre> 
            </div><!-- fetch_values-source -->
            
          </div>

          

          
        </div><!-- fetch_values-method -->
      
        <div id="filter-method" class="method-detail ">
          <a name="method-i-filter"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select {|key, value| ... } &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="Hash.html#method-i-select"><code>Hash#select</code></a>.</p>

<p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>
            

            
            <div class="method-source-code" id="filter-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, keep_if_i, result);
    }
    return result;
}
            </pre> 
            </div><!-- filter-source -->
            
          </div>

          

          
        </div><!-- filter-method -->
      
        <div id="filter-21-method" class="method-detail ">
          <a name="method-i-filter-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select! {|key, value| ... } &rarr; self or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select! &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="Hash.html#method-i-select-21"><code>Hash#select!</code></a>.</p>

<p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p>

<pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select!</span>  <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>
            

            
            <div class="method-source-code" id="filter-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}
            </pre> 
            </div><!-- filter-21-source -->
            
          </div>

          

          
        </div><!-- filter-21-method -->
      
        <div id="flatten-method" class="method-detail ">
          <a name="method-i-flatten"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">flatten &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">flatten(level) &rarr; new_array</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array object that is a 1-dimensional flattening of <code>self</code>.</p>
<hr>

<p>By default, nested Arrays are not flattened:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>], <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span> <span class="ruby-comment"># =&gt; [:foo, 0, :bar, [:bat, 3], :baz, 2]</span>
</pre>

<p>Takes the depth of recursive flattening from Integer argument <code>level</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, [<span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, ]]]}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, [:bat, [:baz, [:bat]]]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, [:baz, [:bat]]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, [:bat]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">4</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
</pre>

<p>When <code>level</code> is negative, flattens all nested Arrays:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, [<span class="ruby-value">:baz</span>, [<span class="ruby-value">:bat</span>, ]]]}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; [:foo, 0, :bar, :bat, :baz, :bat]</span>
</pre>

<p>When <code>level</code> is zero, returns the equivalent of <a href="Hash.html#method-i-to_a"><code>to_a</code></a> :</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> [<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>], <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [[:foo, 0], [:bar, [:bat, 3]], [:baz, 2]]</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">flatten</span>(<span class="ruby-value">0</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="flatten-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_flatten(int argc, VALUE *argv, VALUE hash)
{
    VALUE ary;

    rb_check_arity(argc, 0, 1);

    if (argc) {
        int level = NUM2INT(argv[0]);

        if (level == 0) return rb_hash_to_a(hash);

        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
        level--;

        if (level &gt; 0) {
            VALUE ary_flatten_level = INT2FIX(level);
            rb_funcallv(ary, id_flatten_bang, 1, &amp;ary_flatten_level);
        }
        else if (level &lt; 0) {
            /* flatten recursively */
            rb_funcallv(ary, id_flatten_bang, 0, 0);
        }
    }
    else {
        ary = rb_ary_new_capa(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, ary);
    }

    return ary;
}
            </pre> 
            </div><!-- flatten-source -->
            
          </div>

          

          
        </div><!-- flatten-method -->
      
        <div id="has_key-3F-method" class="method-detail ">
          <a name="method-i-has_key-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">has_key?(key) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="has_key-3F-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    return RBOOL(hash_stlike_lookup(hash, key, NULL));
}
            </pre> 
            </div><!-- has_key-3F-source -->
            
          </div>

          

          
        </div><!-- has_key-3F-method -->
      
        <div id="has_value-3F-method" class="method-detail ">
          <a name="method-i-has_value-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">has_value?(value) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Method.html"><code>Method</code></a> <a href="Hash.html#method-i-value-3F"><code>value?</code></a> is an alias for #has_value?.</p>

<p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="has_value-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}
            </pre> 
            </div><!-- has_value-3F-source -->
            
          </div>

          

          
        </div><!-- has_value-3F-method -->
      
        <div id="hash-method" class="method-detail ">
          <a name="method-i-hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">hash &rarr; an_integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the Integer hash-code for the hash.</p>

<p>Two Hash objects have the same hash-code if their content is the same (regardless or order):</p>

<pre class="ruby"><span class="ruby-identifier">h1</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">baz:</span> <span class="ruby-value">2</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">foo:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h2</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">h1</span>.<span class="ruby-identifier">hash</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">h2</span>.<span class="ruby-identifier">eql?</span> <span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
            

            
            <div class="method-source-code" id="hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_hash(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    st_index_t hval = rb_hash_start(size);
    hval = rb_hash_uint(hval, (st_index_t)rb_hash_hash);
    if (size) {
        rb_hash_foreach(hash, hash_i, (VALUE)&amp;hval);
    }
    hval = rb_hash_end(hval);
    return ST2FIX(hval);
}
            </pre> 
            </div><!-- hash-source -->
            
          </div>

          

          
        </div><!-- hash-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(key) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    return RBOOL(hash_stlike_lookup(hash, key, NULL));
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="initialize_copy-method" class="method-detail ">
          <a name="method-i-initialize_copy"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_hash) &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">replace</span>({<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bam:</span> <span class="ruby-value">4</span>}) <span class="ruby-comment"># =&gt; {:bat=&gt;3, :bam=&gt;4}</span>
</pre>
            

            
            <div class="method-source-code" id="initialize_copy-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, &quot;can&#39;t replace hash during iteration&quot;);
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        ar_free_and_clear_table(hash);
    }
    else {
        st_free_table(RHASH_ST_TABLE(hash));
        RHASH_ST_CLEAR(hash);
    }
    hash_copy(hash, hash2);
    if (RHASH_EMPTY_P(hash2) &amp;&amp; RHASH_ST_TABLE_P(hash2)) {
        /* ident hash */
        RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), 0));
    }

    rb_gc_writebarrier_remember(hash);

    return hash;
}
            </pre> 
            </div><!-- initialize_copy-source -->
            
          </div>

          

          
        </div><!-- initialize_copy-method -->
      
        <div id="inspect-method" class="method-detail ">
          <a name="method-i-inspect"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">inspect &rarr; new_string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new String containing the hash entries:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">inspect</span> <span class="ruby-comment"># =&gt; &quot;{:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}&quot;</span>
</pre>

<p><a href="Hash.html#method-i-to_s"><code>Hash#to_s</code></a> is an alias for <a href="Hash.html#method-i-inspect"><code>Hash#inspect</code></a>.</p>
            

            
            <div class="method-source-code" id="inspect-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_inspect(VALUE hash)
{
    if (RHASH_EMPTY_P(hash))
        return rb_usascii_str_new2(&quot;{}&quot;);
    return rb_exec_recursive(inspect_hash, hash, 0);
}
            </pre> 
            </div><!-- inspect-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Hash.html#method-i-to_s">to_s</a>
          </div>
          

          
        </div><!-- inspect-method -->
      
        <div id="invert-method" class="method-detail ">
          <a name="method-i-invert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">invert &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object with the each key-value pair inverted:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">invert</span>
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}</span>
</pre>

<p>Overwrites any repeated new keys: (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">0</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">0</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">invert</span> <span class="ruby-comment"># =&gt; {0=&gt;:baz}</span>
</pre>
            

            
            <div class="method-source-code" id="invert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_invert(VALUE hash)
{
    VALUE h = rb_hash_new_with_size(RHASH_SIZE(hash));

    rb_hash_foreach(hash, rb_hash_invert_i, h);
    return h;
}
            </pre> 
            </div><!-- invert-source -->
            
          </div>

          

          
        </div><!-- invert-method -->
      
        <div id="keep_if-method" class="method-detail ">
          <a name="method-i-keep_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keep_if {|key, value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">keep_if &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Calls the block for each key-value pair; retains the entry if the block returns a truthy value; otherwise deletes the entry; returns <code>self</code>.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">keep_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">keep_if</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:keep_if&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="keep_if-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_keep_if(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_foreach(hash, keep_if_i, hash);
    }
    return hash;
}
            </pre> 
            </div><!-- keep_if-source -->
            
          </div>

          

          
        </div><!-- keep_if-method -->
      
        <div id="key-method" class="method-detail ">
          <a name="method-i-key"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key(value) &rarr; key or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the key for the first-found entry with the given <code>value</code> (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">2</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">key</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; :foo</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">key</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; :bar</span>
</pre>

<p>Returns <code>nil</code> if so such value is found.</p>
            

            
            <div class="method-source-code" id="key-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_key(VALUE hash, VALUE value)
{
    VALUE args[2];

    args[0] = value;
    args[1] = Qnil;

    rb_hash_foreach(hash, key_i, (VALUE)args);

    return args[1];
}
            </pre> 
            </div><!-- key-source -->
            
          </div>

          

          
        </div><!-- key-method -->
      
        <div id="key-3F-method" class="method-detail ">
          <a name="method-i-key-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key?(key) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="key-3F-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    return RBOOL(hash_stlike_lookup(hash, key, NULL));
}
            </pre> 
            </div><!-- key-3F-source -->
            
          </div>

          

          
        </div><!-- key-3F-method -->
      
        <div id="keys-method" class="method-detail ">
          <a name="method-i-keys"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keys &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array containing all keys in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">keys</span> <span class="ruby-comment"># =&gt; [:foo, :bar, :baz]</span>
</pre>
            

            
            <div class="method-source-code" id="keys-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_keys(VALUE hash)
{
    st_index_t size = RHASH_SIZE(hash);
    VALUE keys =  rb_ary_new_capa(size);

    if (size == 0) return keys;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        RARRAY_PTR_USE_TRANSIENT(keys, ptr, {
            if (RHASH_AR_TABLE_P(hash)) {
                size = ar_keys(hash, ptr, size);
            }
            else {
                st_table *table = RHASH_ST_TABLE(hash);
                size = st_keys(table, ptr, size);
            }
        });
        rb_gc_writebarrier_remember(keys);
        rb_ary_set_len(keys, size);
    }
    else {
        rb_hash_foreach(hash, keys_i, keys);
    }

    return keys;
}
            </pre> 
            </div><!-- keys-source -->
            
          </div>

          

          
        </div><!-- keys-method -->
      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the count of entries in <code>self</code>:</p>

<pre class="ruby">{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Hash.html#method-i-length"><code>Hash#length</code></a> is an alias for <a href="Hash.html#method-i-size"><code>Hash#size</code></a>.</p>
            

            
            <div class="method-source-code" id="length-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}
            </pre> 
            </div><!-- length-source -->
            
          </div>

          

          
        </div><!-- length-method -->
      
        <div id="member-3F-method" class="method-detail ">
          <a name="method-i-member-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">member?(key) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Methods <a href="Hash.html#method-i-has_key-3F"><code>has_key?</code></a>, <a href="Hash.html#method-i-key-3F"><code>key?</code></a>, and <a href="Hash.html#method-i-member-3F"><code>member?</code></a> are aliases for #include?.</p>

<p>Returns <code>true</code> if <code>key</code> is a key in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="member-3F-source">
              <pre> <!-- method.markup_code 290 -->
               MJIT_FUNC_EXPORTED VALUE
rb_hash_has_key(VALUE hash, VALUE key)
{
    return RBOOL(hash_stlike_lookup(hash, key, NULL));
}
            </pre> 
            </div><!-- member-3F-source -->
            
          </div>

          

          
        </div><!-- member-3F-method -->
      
        <div id="merge-method" class="method-detail ">
          <a name="method-i-merge"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">merge &rarr; copy_of_self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge(*other_hashes) &rarr; new_hash</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge(*other_hashes) { |key, old_value, new_value| ... } &rarr; new_hash</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the new Hash formed by merging each of <code>other_hashes</code> into a copy of <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>
<hr>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns the new Hash object formed by merging each successive Hash in <code>other_hashes</code> into <code>self</code>.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns a new Hash object that is the merge of <code>self</code> and each given hash.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns a copy of <code>self</code>.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="merge-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_merge(int argc, VALUE *argv, VALUE self)
{
    return rb_hash_update(argc, argv, copy_compare_by_id(rb_hash_dup(self), self));
}
            </pre> 
            </div><!-- merge-source -->
            
          </div>

          

          
        </div><!-- merge-method -->
      
        <div id="merge-21-method" class="method-detail ">
          <a name="method-i-merge-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">merge! &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge!(*other_hashes) &rarr; self</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge!(*other_hashes) { |key, old_value, new_value| ... } &rarr; self</span>
            
          </div>
          
          
          <div>
  
            
            <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>

<p>Method <a href="Hash.html#method-i-update"><code>update</code></a> is an alias for #merge!.</p>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged into it.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns <code>self</code>, unmodified.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="merge-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
        VALUE hash = to_hash(argv[i]);
        if (block_given) {
            rb_hash_foreach(hash, rb_hash_update_block_i, self);
        }
        else {
            rb_hash_foreach(hash, rb_hash_update_i, self);
        }
    }
    return self;
}
            </pre> 
            </div><!-- merge-21-source -->
            
          </div>

          

          
        </div><!-- merge-21-method -->
      
        <div id="rassoc-method" class="method-detail ">
          <a name="method-i-rassoc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rassoc(value) &rarr; new_array or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new 2-element Array consisting of the key and value of the first-found entry whose value is <code>==</code> to value (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">rassoc</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [:bar, 1]</span>
</pre>

<p>Returns <code>nil</code> if no such value found.</p>
            

            
            <div class="method-source-code" id="rassoc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_rassoc(VALUE hash, VALUE obj)
{
    VALUE args[2];

    args[0] = obj;
    args[1] = Qnil;
    rb_hash_foreach(hash, rassoc_i, (VALUE)args);
    return args[1];
}
            </pre> 
            </div><!-- rassoc-source -->
            
          </div>

          

          
        </div><!-- rassoc-method -->
      
        <div id="rehash-method" class="method-detail ">
          <a name="method-i-rehash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rehash &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Rebuilds the hash table by recomputing the hash index for each key; returns <code>self</code>.</p>

<p>The hash table becomes invalid if the hash value of a key has changed after the entry was created. See <a href="#class-Hash-label-Modifying+an+Active+Hash+Key">Modifying an Active Hash Key</a>.</p>
            

            
            <div class="method-source-code" id="rehash-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_rehash(VALUE hash)
{
    VALUE tmp;
    st_table *tbl;

    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, &quot;rehash during iteration&quot;);
    }
    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        tmp = hash_alloc(0);
        ar_alloc_table(tmp);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        ar_free_and_clear_table(hash);
        ar_copy(hash, tmp);
        ar_free_and_clear_table(tmp);
    }
    else if (RHASH_ST_TABLE_P(hash)) {
        st_table *old_tab = RHASH_ST_TABLE(hash);
        tmp = hash_alloc(0);
        tbl = st_init_table_with_size(old_tab-&gt;type, old_tab-&gt;num_entries);
        RHASH_ST_TABLE_SET(tmp, tbl);
        rb_hash_foreach(hash, rb_hash_rehash_i, (VALUE)tmp);
        st_free_table(old_tab);
        RHASH_ST_TABLE_SET(hash, tbl);
        RHASH_ST_CLEAR(tmp);
    }
    hash_verify(hash);
    return hash;
}
            </pre> 
            </div><!-- rehash-source -->
            
          </div>

          

          
        </div><!-- rehash-method -->
      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject {|key, value| ... } &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object whose entries are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>
            

            
            <div class="method-source-code" id="reject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_reject(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, delete_if_i, result);
    }
    return result;
}
            </pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->
      
        <div id="reject-21-method" class="method-detail ">
          <a name="method-i-reject-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject! {|key, value| ... } &rarr; self or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">reject! &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code>, whose remaining entries are those for which the block returns <code>false</code> or <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:baz=&gt;2}</span>
</pre>

<p>Returns <code>nil</code> if no entries are removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">reject!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:reject!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;b&#39;</span>) } <span class="ruby-comment"># =&gt; {:foo=&gt;0}</span>
</pre>
            

            
            <div class="method-source-code" id="reject-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_reject_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, delete_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}
            </pre> 
            </div><!-- reject-21-source -->
            
          </div>

          

          
        </div><!-- reject-21-method -->
      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other_hash) &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the entire contents of <code>self</code> with the contents of <code>other_hash</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">replace</span>({<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bam:</span> <span class="ruby-value">4</span>}) <span class="ruby-comment"># =&gt; {:bat=&gt;3, :bam=&gt;4}</span>
</pre>
            

            
            <div class="method-source-code" id="replace-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_replace(VALUE hash, VALUE hash2)
{
    rb_hash_modify_check(hash);
    if (hash == hash2) return hash;
    if (RHASH_ITER_LEV(hash) &gt; 0) {
        rb_raise(rb_eRuntimeError, &quot;can&#39;t replace hash during iteration&quot;);
    }
    hash2 = to_hash(hash2);

    COPY_DEFAULT(hash, hash2);

    if (RHASH_AR_TABLE_P(hash)) {
        ar_free_and_clear_table(hash);
    }
    else {
        st_free_table(RHASH_ST_TABLE(hash));
        RHASH_ST_CLEAR(hash);
    }
    hash_copy(hash, hash2);
    if (RHASH_EMPTY_P(hash2) &amp;&amp; RHASH_ST_TABLE_P(hash2)) {
        /* ident hash */
        RHASH_ST_TABLE_SET(hash, st_init_table_with_size(RHASH_TYPE(hash2), 0));
    }

    rb_gc_writebarrier_remember(hash);

    return hash;
}
            </pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select {|key, value| ... } &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-filter"><code>Hash#filter</code></a> is an alias for <a href="Hash.html#method-i-select"><code>Hash#select</code></a>.</p>

<p>Returns a new Hash object whose entries are those for which the block returns a truthy value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_select(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_foreach(result, keep_if_i, result);
    }
    return result;
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->
      
        <div id="select-21-method" class="method-detail ">
          <a name="method-i-select-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select! {|key, value| ... } &rarr; self or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">select! &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-filter-21"><code>Hash#filter!</code></a> is an alias for <a href="Hash.html#method-i-select-21"><code>Hash#select!</code></a>.</p>

<p>Returns <code>self</code>, whose entries are those for which the block returns a truthy value:</p>

<pre>h = {foo: 0, bar: 1, baz: 2}
h.select! {|key, value| value &lt; 2 }  =&gt; {:foo=&gt;0, :bar=&gt;1}</pre>

<p>Returns <code>nil</code> if no entries were removed.</p>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">select!</span>  <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:select!&gt;</span>
<span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> } <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1}</span>
</pre>
            

            
            <div class="method-source-code" id="select-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_select_bang(VALUE hash)
{
    st_index_t n;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);
    n = RHASH_SIZE(hash);
    if (!n) return Qnil;
    rb_hash_foreach(hash, keep_if_i, hash);
    if (n == RHASH_SIZE(hash)) return Qnil;
    return hash;
}
            </pre> 
            </div><!-- select-21-source -->
            
          </div>

          

          
        </div><!-- select-21-method -->
      
        <div id="shift-method" class="method-detail ">
          <a name="method-i-shift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shift &rarr; [key, value] or default_value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the first hash entry (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>); returns a 2-element Array containing the removed key and value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">shift</span> <span class="ruby-comment"># =&gt; [:foo, 0]</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:bar=&gt;1, :baz=&gt;2}</span>
</pre>

<p>Returns the default value if the hash is empty (see <a href="#class-Hash-label-Default+Values">Default Values</a>).</p>
            

            
            <div class="method-source-code" id="shift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_shift(VALUE hash)
{
    struct shift_var var;

    rb_hash_modify_check(hash);
    if (RHASH_AR_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (ar_shift(hash, &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    if (RHASH_ST_TABLE_P(hash)) {
        var.key = Qundef;
        if (RHASH_ITER_LEV(hash) == 0) {
            if (st_shift(RHASH_ST_TABLE(hash), &amp;var.key, &amp;var.val)) {
                return rb_assoc_new(var.key, var.val);
            }
        }
        else {
            rb_hash_foreach(hash, shift_i_safe, (VALUE)&amp;var);
            if (var.key != Qundef) {
                rb_hash_delete_entry(hash, var.key);
                return rb_assoc_new(var.key, var.val);
            }
        }
    }
    return rb_hash_default_value(hash, Qnil);
}
            </pre> 
            </div><!-- shift-source -->
            
          </div>

          

          
        </div><!-- shift-method -->
      
        <div id="size-method" class="method-detail ">
          <a name="method-i-size"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">size &rarr; integer</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the count of entries in <code>self</code>:</p>

<pre class="ruby">{<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}.<span class="ruby-identifier">length</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Hash.html#method-i-length"><code>Hash#length</code></a> is an alias for <a href="Hash.html#method-i-size"><code>Hash#size</code></a>.</p>
            

            
            <div class="method-source-code" id="size-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_size(VALUE hash)
{
    return INT2FIX(RHASH_SIZE(hash));
}
            </pre> 
            </div><!-- size-source -->
            
          </div>

          

          
        </div><!-- size-method -->
      
        <div id="slice-method" class="method-detail ">
          <a name="method-i-slice"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">slice(*keys) &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object containing the entries for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; {:baz=&gt;2, :foo=&gt;0}</span>
</pre>

<p>Any given <code>keys</code> that are not found are ignored.</p>
            

            
            <div class="method-source-code" id="slice-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_slice(int argc, VALUE *argv, VALUE hash)
{
    int i;
    VALUE key, value, result;

    if (argc == 0 || RHASH_EMPTY_P(hash)) {
        return copy_compare_by_id(rb_hash_new(), hash);
    }
    result = copy_compare_by_id(rb_hash_new_with_size(argc), hash);

    for (i = 0; i &lt; argc; i++) {
        key = argv[i];
        value = rb_hash_lookup2(hash, key, Qundef);
        if (value != Qundef)
            rb_hash_aset(result, key, value);
    }

    return result;
}
            </pre> 
            </div><!-- slice-source -->
            
          </div>

          

          
        </div><!-- slice-method -->
      
        <div id="store-method" class="method-detail ">
          <a name="method-i-store"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">store(key, value)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Hash.html#method-i-store"><code>Hash#store</code></a> is an alias for <a href="Hash.html#method-i-5B-5D-3D"><code>Hash#[]=</code></a>.</p>

<p>Associates the given <code>value</code> with the given <code>key</code>; returns <code>value</code>.</p>

<p>If the given <code>key</code> exists, replaces its value with the given <code>value</code>; the ordering is not affected (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:foo</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bar</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;2, :bar=&gt;3}</span>
</pre>

<p>If <code>key</code> does not exist, adds the <code>key</code> and <code>value</code>; the new entry is last in the order (see <a href="#class-Hash-label-Entry+Order">Entry Order</a>):</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>}
<span class="ruby-identifier">h</span>[<span class="ruby-value">:baz</span>] = <span class="ruby-value">2</span> <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">store</span>(<span class="ruby-value">:bat</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-identifier">h</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2, :bat=&gt;3}</span>
</pre>
            

            
            <div class="method-source-code" id="store-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_aset(VALUE hash, VALUE key, VALUE val)
{
    int iter_lev = RHASH_ITER_LEV(hash);

    rb_hash_modify(hash);

    if (RHASH_TABLE_NULL_P(hash)) {
        if (iter_lev &gt; 0) no_new_key();
        ar_alloc_table(hash);
    }

    if (RHASH_TYPE(hash) == &amp;identhash || rb_obj_class(key) != rb_cString) {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset, val);
    }
    else {
        RHASH_UPDATE_ITER(hash, iter_lev, key, hash_aset_str, val);
    }
    return val;
}
            </pre> 
            </div><!-- store-source -->
            
          </div>

          

          
        </div><!-- store-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array of 2-element Array objects; each nested Array contains a key-value pair from <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_a</span> <span class="ruby-comment"># =&gt; [[:foo, 0], [:bar, 1], [:baz, 2]]</span>
</pre>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_to_a(VALUE hash)
{
    VALUE ary;

    ary = rb_ary_new_capa(RHASH_SIZE(hash));
    rb_hash_foreach(hash, to_a_i, ary);

    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_h-method" class="method-detail ">
          <a name="method-i-to_h"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_h &rarr; self or new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">to_h {|key, value| ... } &rarr; new_hash</span>
            
          </div>
          
          
          <div>
  
            
            <p>For an instance of Hash, returns <code>self</code>.</p>

<p>For a subclass of Hash, returns a new Hash containing the content of <code>self</code>.</p>

<p>When a block is given, returns a new Hash object whose content is based on the block; the block should return a 2-element Array object specifying the key-value pair to be included in the returned Array:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_h</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">value</span>, <span class="ruby-identifier">key</span>] }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}</span>
</pre>
            

            
            <div class="method-source-code" id="to_h-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_to_h(VALUE hash)
{
    if (rb_block_given_p()) {
        return rb_hash_to_h_block(hash);
    }
    if (rb_obj_class(hash) != rb_cHash) {
        const VALUE flags = RBASIC(hash)-&gt;flags;
        hash = hash_dup(hash, rb_cHash, flags &amp; RHASH_PROC_DEFAULT);
    }
    return hash;
}
            </pre> 
            </div><!-- to_h-source -->
            
          </div>

          

          
        </div><!-- to_h-method -->
      
        <div id="to_hash-method" class="method-detail ">
          <a name="method-i-to_hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_hash &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code>.</p>
            

            
            <div class="method-source-code" id="to_hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_to_hash(VALUE hash)
{
    return hash;
}
            </pre> 
            </div><!-- to_hash-source -->
            
          </div>

          

          
        </div><!-- to_hash-method -->
      
        <div id="to_proc-method" class="method-detail ">
          <a name="method-i-to_proc"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_proc &rarr; proc</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a Proc object that maps a key to its value:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">proc</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">to_proc</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">class</span> <span class="ruby-comment"># =&gt; Proc</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:bar</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">proc</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:nosuch</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>
            

            
            <div class="method-source-code" id="to_proc-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_to_proc(VALUE hash)
{
    return rb_func_lambda_new(hash_proc_call, hash, 1, 1);
}
            </pre> 
            </div><!-- to_proc-source -->
            
          </div>

          

          
        </div><!-- to_proc-method -->
      
        <div id="to_s-method" class="method-detail method-alias">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          
          <div>
  
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Hash.html#method-i-inspect">inspect</a>
          </div>
          
        </div><!-- to_s-method -->
      
        <div id="transform_keys-method" class="method-detail ">
          <a name="method-i-transform_keys"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys {|key| ... } &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys(hash2) &rarr; new_hash</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys(hash2) {|other_key| ...} &rarr; new_hash</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object; each entry has:</p>
<ul><li>
<p>A key provided by the block.</p>
</li><li>
<p>The value from <code>self</code>.</p>
</li></ul>

<p>An optional hash argument can be provided to map keys to new keys. Any key not given will be mapped using the provided block, or remain the same if no block is given.</p>

<p>Transform keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>

<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">:bar</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">:foo</span>)
<span class="ruby-comment">#=&gt; {bar: 0, foo: 1, baz: 2}</span>

<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span>(<span class="ruby-value">foo:</span> <span class="ruby-value">:hello</span>, <span class="ruby-operator">&amp;</span><span class="ruby-value">:to_s</span>)
<span class="ruby-comment">#=&gt; {:hello=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>
</pre>

<p>Overwrites values for duplicate keys:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-value">:bat</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:bat=&gt;2}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_keys</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_keys&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span> <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {&quot;foo&quot;=&gt;0, &quot;bar&quot;=&gt;1, &quot;baz&quot;=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="transform_keys-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_transform_keys(int argc, VALUE *argv, VALUE hash)
{
    VALUE result;
    struct transform_keys_args transarg = {0};

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        transarg.trans = to_hash(argv[0]);
        transarg.block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    result = rb_hash_new();
    if (!RHASH_EMPTY_P(hash)) {
        if (transarg.trans) {
            transarg.result = result;
            rb_hash_foreach(hash, transform_keys_hash_i, (VALUE)&amp;transarg);
        }
        else {
            rb_hash_foreach(hash, transform_keys_i, result);
        }
    }

    return result;
}
            </pre> 
            </div><!-- transform_keys-source -->
            
          </div>

          

          
        </div><!-- transform_keys-method -->
      
        <div id="transform_keys-21-method" class="method-detail ">
          <a name="method-i-transform_keys-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys! {|key| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys!(hash2) &rarr; self</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys!(hash2) {|other_key| ...} &rarr; self</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_keys! &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Same as <a href="Hash.html#method-i-transform_keys"><code>Hash#transform_keys</code></a> but modifies the receiver in place instead of returning a new hash.</p>
            

            
            <div class="method-source-code" id="transform_keys-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_transform_keys_bang(int argc, VALUE *argv, VALUE hash)
{
    VALUE trans = 0;
    int block_given = 0;

    argc = rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        trans = to_hash(argv[0]);
        block_given = rb_block_given_p();
    }
    else {
        RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    }
    rb_hash_modify_check(hash);
    if (!RHASH_TABLE_EMPTY_P(hash)) {
        long i;
        VALUE new_keys = hash_alloc(0);
        VALUE pairs = rb_ary_tmp_new(RHASH_SIZE(hash) * 2);
        rb_hash_foreach(hash, flatten_i, pairs);
        for (i = 0; i &lt; RARRAY_LEN(pairs); i += 2) {
            VALUE key = RARRAY_AREF(pairs, i), new_key, val;

            if (!trans) {
                new_key = rb_yield(key);
            }
            else if ((new_key = rb_hash_lookup2(trans, key, Qundef)) != Qundef) {
                /* use the transformed key */
            }
            else if (block_given) {
                new_key = rb_yield(key);
            }
            else {
                new_key = key;
            }
            val = RARRAY_AREF(pairs, i+1);
            if (!hash_stlike_lookup(new_keys, key, NULL)) {
                rb_hash_stlike_delete(hash, &amp;key, NULL);
            }
            rb_hash_aset(hash, new_key, val);
            rb_hash_aset(new_keys, new_key, Qnil);
        }
        rb_ary_clear(pairs);
        rb_hash_clear(new_keys);
    }
    return hash;
}
            </pre> 
            </div><!-- transform_keys-21-source -->
            
          </div>

          

          
        </div><!-- transform_keys-21-method -->
      
        <div id="transform_values-method" class="method-detail ">
          <a name="method-i-transform_values"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transform_values {|value| ... } &rarr; new_hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_values &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Hash object; each entry has:</p>
<ul><li>
<p>A key from <code>self</code>.</p>
</li><li>
<p>A value provided by the block.</p>
</li></ul>

<p>Transform values:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}:transform_values&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>
            

            
            <div class="method-source-code" id="transform_values-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_transform_values(VALUE hash)
{
    VALUE result;

    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    result = hash_dup_with_compare_by_id(hash);
    SET_DEFAULT(result, Qnil);

    if (!RHASH_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(result, transform_values_foreach_func, transform_values_foreach_replace, result);
    }

    return result;
}
            </pre> 
            </div><!-- transform_values-source -->
            
          </div>

          

          
        </div><!-- transform_values-method -->
      
        <div id="transform_values-21-method" class="method-detail ">
          <a name="method-i-transform_values-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">transform_values! {|value| ... } &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">transform_values! &rarr; new_enumerator</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns <code>self</code>, whose keys are unchanged, and whose values are determined by the given block.</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values!</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>} <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>

<p>Returns a new Enumerator if no block given:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">e</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">transform_values!</span> <span class="ruby-comment"># =&gt; #&lt;Enumerator: {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}:transform_values!&gt;</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">e</span>.<span class="ruby-identifier">each</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">value</span> <span class="ruby-operator">*</span> <span class="ruby-value">100</span>}
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;100, :baz=&gt;200}</span>
</pre>
            

            
            <div class="method-source-code" id="transform_values-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_transform_values_bang(VALUE hash)
{
    RETURN_SIZED_ENUMERATOR(hash, 0, 0, hash_enum_size);
    rb_hash_modify_check(hash);

    if (!RHASH_TABLE_EMPTY_P(hash)) {
        rb_hash_stlike_foreach_with_replace(hash, transform_values_foreach_func, transform_values_foreach_replace, hash);
    }

    return hash;
}
            </pre> 
            </div><!-- transform_values-21-source -->
            
          </div>

          

          
        </div><!-- transform_values-21-method -->
      
        <div id="update-method" class="method-detail ">
          <a name="method-i-update"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">merge! &rarr; self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge!(*other_hashes) &rarr; self</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">merge!(*other_hashes) { |key, old_value, new_value| ... } &rarr; self</span>
            
          </div>
          
          
          <div>
  
            
            <p>Merges each of <code>other_hashes</code> into <code>self</code>; returns <code>self</code>.</p>

<p>Each argument in <code>other_hashes</code> must be a Hash.</p>

<p>Method <a href="Hash.html#method-i-update"><code>update</code></a> is an alias for #merge!.</p>

<p>With arguments and no block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged into it.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new entry is added at the end.</p>
</li><li>
<p>Each duplicate-key entry&#39;s value overwrites the previous value.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;4, :baz=&gt;2, :bat=&gt;6, :bam=&gt;5}</span>
</pre>

<p>With arguments and a block:</p>
<ul><li>
<p>Returns <code>self</code>, after the given hashes are merged.</p>
</li><li>
<p>The given hashes are merged left to right.</p>
</li><li>
<p>Each new-key entry is added at the end.</p>
</li><li>
<p>For each duplicate key:</p>
<ul><li>
<p>Calls the block with the key and the old and new values.</p>
</li><li>
<p>The block&#39;s return value becomes the new value for the entry.</p>
</li></ul>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h1</span> = {<span class="ruby-value">bat:</span> <span class="ruby-value">3</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">4</span>}
<span class="ruby-identifier">h2</span> = {<span class="ruby-value">bam:</span> <span class="ruby-value">5</span>, <span class="ruby-value">bat:</span><span class="ruby-value">6</span>}
<span class="ruby-identifier">h3</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">h1</span>, <span class="ruby-identifier">h2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">new_value</span> }
<span class="ruby-identifier">h3</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;5, :baz=&gt;2, :bat=&gt;9, :bam=&gt;5}</span>
</pre>

<p>With no arguments:</p>
<ul><li>
<p>Returns <code>self</code>, unmodified.</p>
</li><li>
<p>The block, if given, is ignored.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
<span class="ruby-identifier">h1</span> = <span class="ruby-identifier">h</span>.<span class="ruby-identifier">merge!</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span><span class="ruby-operator">|</span> <span class="ruby-identifier">raise</span> <span class="ruby-string">&#39;Cannot happen&#39;</span> }
<span class="ruby-identifier">h1</span> <span class="ruby-comment"># =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}</span>
</pre>
            

            
            <div class="method-source-code" id="update-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_update(int argc, VALUE *argv, VALUE self)
{
    int i;
    bool block_given = rb_block_given_p();

    rb_hash_modify(self);
    for (i = 0; i &lt; argc; i++){
        VALUE hash = to_hash(argv[i]);
        if (block_given) {
            rb_hash_foreach(hash, rb_hash_update_block_i, self);
        }
        else {
            rb_hash_foreach(hash, rb_hash_update_i, self);
        }
    }
    return self;
}
            </pre> 
            </div><!-- update-source -->
            
          </div>

          

          
        </div><!-- update-method -->
      
        <div id="value-3F-method" class="method-detail ">
          <a name="method-i-value-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">value?(value) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p><a href="Method.html"><code>Method</code></a> <a href="Hash.html#method-i-value-3F"><code>value?</code></a> is an alias for #has_value?.</p>

<p>Returns <code>true</code> if <code>value</code> is a value in <code>self</code>, otherwise <code>false</code>.</p>
            

            
            <div class="method-source-code" id="value-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_has_value(VALUE hash, VALUE val)
{
    VALUE data[2];

    data[0] = Qfalse;
    data[1] = val;
    rb_hash_foreach(hash, rb_hash_search_value, (VALUE)data);
    return data[0];
}
            </pre> 
            </div><!-- value-3F-source -->
            
          </div>

          

          
        </div><!-- value-3F-method -->
      
        <div id="values-method" class="method-detail ">
          <a name="method-i-values"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array containing all values in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">values</span> <span class="ruby-comment"># =&gt; [0, 1, 2]</span>
</pre>
            

            
            <div class="method-source-code" id="values-source">
              <pre> <!-- method.markup_code 290 -->
               VALUE
rb_hash_values(VALUE hash)
{
    VALUE values;
    st_index_t size = RHASH_SIZE(hash);

    values = rb_ary_new_capa(size);
    if (size == 0) return values;

    if (ST_DATA_COMPATIBLE_P(VALUE)) {
        if (RHASH_AR_TABLE_P(hash)) {
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = ar_values(hash, ptr, size);
            });
        }
        else if (RHASH_ST_TABLE_P(hash)) {
            st_table *table = RHASH_ST_TABLE(hash);
            rb_gc_writebarrier_remember(values);
            RARRAY_PTR_USE_TRANSIENT(values, ptr, {
                size = st_values(table, ptr, size);
            });
        }
        rb_ary_set_len(values, size);
    }

    else {
        rb_hash_foreach(hash, values_i, values);
    }

    return values;
}
            </pre> 
            </div><!-- values-source -->
            
          </div>

          

          
        </div><!-- values-method -->
      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(*keys) &rarr; new_array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new Array containing values for the given <code>keys</code>:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-value">0</span>, <span class="ruby-value">bar:</span> <span class="ruby-value">1</span>, <span class="ruby-value">baz:</span> <span class="ruby-value">2</span>}
<span class="ruby-identifier">h</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:baz</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [2, 0]</span>
</pre>

<p>The <a href="#class-Hash-label-Default+Values">default values</a> are returned for any keys that are not found:</p>

<pre class="ruby"><span class="ruby-identifier">h</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-value">:hello</span>, <span class="ruby-value">:foo</span>) <span class="ruby-comment"># =&gt; [nil, 0]</span>
</pre>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
rb_hash_values_at(int argc, VALUE *argv, VALUE hash)
{
    VALUE result = rb_ary_new2(argc);
    long i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(result, rb_hash_aref(hash, argv[i]));
    }
    return result;
}
            </pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_Hash_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Hash_versioned").load("/associated/3.1.2/Hash.ihtml");</script> <div id='tx_Hash' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_Hash").load("/associated/Hash.ihtml");</script> 
      
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 3.1.2</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>. <a href="http://neurogami.com">Maximum R+D</a>.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>
 
       <p><small>Generated with Ruby-doc Rdoc Generator 0.42.0</small>.</p>
  </div>
</div>
  
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.ihtml");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
	} 

   //function loadInline(json){
   // for (var lookFor in json) {
    //  $(lookFor).after(json[lookFor]);
    // }
  // } // end loadInline


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/3.1.2/plus_Hash.ihtml', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


//     $.ajax({
//     dataType: "json",
//      url: '/associated/3.1.2/inline_Hash.js',
//      success: function(json) {
// 			setTimeout(function() {
// 				loadInline(json);
// 				}, 2000);
// 			}
//    });

		});
</script>
		
</body>
</html>


