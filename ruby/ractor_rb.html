<!doctype html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <!-- RD version: 0.42.0  -->
    <!--  filepage  -->
  <meta charset="utf-8">
          
  <!-- Use the .htaccess and remove these lines to avoid edge case issues.
       More info: h5bp.com/b/378 -->
  <!-- meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" -->


	<title>File: ractor.rb [Ruby 3.1.2]</title>
  <link rel="stylesheet" href="./css/associated.css" type="text/css" >
  <link rel="stylesheet" href="./css/inuit.css" >
  <link rel="stylesheet" href="./css/grid.inuit.css" >
  <link rel="stylesheet" href="./css/2011.css" type="text/css" >
  <link rel="stylesheet" href="./css/rdoc.css" type="text/css" >
    <link rel="stylesheet" href="./css/carbon17.css" type="text/css" >

  <!-- rel_prefix  = '' -->
    
    <!-- WHY? -->
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = '.'  --> 
  <link rel="stylesheet" href="css/extra.css" type="text/css" >
  <script  src="/js/extra.js"  ></script>


</head>

<body class="file file-popup">
	<div id="metadata">
		<dl>
			<dt class="modified-date">Last Modified</dt>
			<dd class="modified-date">2022-04-12 04:11:15 -0700</dd>

			
			<dt class="requires">Requires</dt>
			<dd class="requires">
				<ul>
				
				</ul>
			</dd>
			

			
		</dl>
	</div>

	<div id="documentation">
		
		<div class="description">
			<h2>Description</h2>
			
<p><a href="Ractor.html"><code>Ractor</code></a> is a Actor-model abstraction for Ruby that provides thread-safe parallel execution.</p>

<p><a href="Ractor.html#method-c-new"><code>Ractor.new</code></a> can make a new <a href="Ractor.html"><code>Ractor</code></a>, and it will run in parallel.</p>

<pre class="ruby"><span class="ruby-comment"># The simplest ractor</span>
<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> {<span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;I am in Ractor!&quot;</span>}
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span> <span class="ruby-comment"># wait for it to finish</span>
<span class="ruby-comment"># here &quot;I am in Ractor!&quot; would be printed</span>
</pre>

<p>Ractors do not share usual objects, so the same kinds of thread-safety concerns such as data-race, race-conditions are not available on multi-ractor programming.</p>

<p>To achieve this, ractors severely limit object sharing between different ractors. For example, unlike threads, ractors can&#39;t access each other&#39;s objects, nor any objects through variables of the outer scope.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>
<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> {<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I am in Ractor! a=#{a}&quot;</span>}
<span class="ruby-comment"># fails immediately with</span>
<span class="ruby-comment"># ArgumentError (can not isolate a Proc because it accesses outer variables (a).)</span>
</pre>

<p>On CRuby (the default implementation), Global Virtual Machine Lock (GVL) is held per ractor, so ractors are performed in parallel without locking each other.</p>

<p>Instead of accessing the shared state, the objects should be passed to and from ractors via sending and receiving objects as messages.</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>
<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">a_in_ractor</span> = <span class="ruby-identifier">receive</span> <span class="ruby-comment"># receive blocks till somebody will pass message</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I am in Ractor! a=#{a_in_ractor}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">a</span>)  <span class="ruby-comment"># pass it</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># here &quot;I am in Ractor! a=1&quot; would be printed</span>
</pre>

<p>There are two pairs of methods for sending/receiving messages:</p>
<ul><li>
<p><a href="Ractor.html#method-i-send"><code>Ractor#send</code></a> and <a href="Ractor.html#method-c-receive"><code>Ractor.receive</code></a> for when the <em>sender</em> knows the receiver (push);</p>
</li><li>
<p><a href="Ractor.html#method-c-yield"><code>Ractor.yield</code></a> and <a href="Ractor.html#method-i-take"><code>Ractor#take</code></a> for when the <em>receiver</em> knows the sender (pull);</p>
</li></ul>

<p>In addition to that, an argument to <a href="Ractor.html#method-c-new"><code>Ractor.new</code></a> would be passed to block and available there as if received by <a href="Ractor.html#method-c-receive"><code>Ractor.receive</code></a>, and the last block value would be sent outside of the ractor as if sent by <a href="Ractor.html#method-c-yield"><code>Ractor.yield</code></a>.</p>

<p>A little demonstration on a classic ping-pong:</p>

<pre class="ruby"><span class="ruby-identifier">server</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Server starts: #{self.inspect}&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Server sends: ping&quot;</span>
  <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">yield</span> <span class="ruby-string">&#39;ping&#39;</span>                       <span class="ruby-comment"># The server doesn&#39;t know the receiver and sends to whoever interested</span>
  <span class="ruby-identifier">received</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">receive</span>                 <span class="ruby-comment"># The server doesn&#39;t know the sender and receives from whoever sent</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Server received: #{received}&quot;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">client</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">server</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">srv</span><span class="ruby-operator">|</span>        <span class="ruby-comment"># The server is sent inside client, and available as srv</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Client starts: #{self.inspect}&quot;</span>
  <span class="ruby-identifier">received</span> = <span class="ruby-identifier">srv</span>.<span class="ruby-identifier">take</span>                       <span class="ruby-comment"># The Client takes a message specifically from the server</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Client received from &quot;</span> \
       <span class="ruby-node">&quot;#{srv.inspect}: #{received}&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;Client sends to &quot;</span> \
       <span class="ruby-node">&quot;#{srv.inspect}: pong&quot;</span>
  <span class="ruby-identifier">srv</span>.<span class="ruby-identifier">send</span> <span class="ruby-string">&#39;pong&#39;</span>                           <span class="ruby-comment"># The client sends a message specifically to the server</span>
<span class="ruby-keyword">end</span>

[<span class="ruby-identifier">client</span>, <span class="ruby-identifier">server</span>].<span class="ruby-identifier">each</span>(<span class="ruby-operator">&amp;</span><span class="ruby-value">:take</span>)               <span class="ruby-comment"># Wait till they both finish</span>
</pre>

<p>This will output:</p>

<pre>Server starts: #&lt;Ractor:#2 test.rb:1 running&gt;
Server sends: ping
Client starts: #&lt;Ractor:#3 test.rb:8 running&gt;
Client received from #&lt;Ractor:#2 rac.rb:1 blocking&gt;: ping
Client sends to #&lt;Ractor:#2 rac.rb:1 blocking&gt;: pong
Server received: pong</pre>

<p>It is said that <a href="Ractor.html"><code>Ractor</code></a> receives messages via the <em>incoming port</em>, and sends them to the <em>outgoing port</em>. Either one can be disabled with <a href="Ractor.html#method-i-close_incoming"><code>Ractor#close_incoming</code></a> and <a href="Ractor.html#method-i-close_outgoing"><code>Ractor#close_outgoing</code></a> respectively. If a ractor terminated, its ports will be closed automatically.</p>

<h2 id="label-Shareable+and+unshareable+objects">Shareable and unshareable objects<span><a href="#label-Shareable+and+unshareable+objects">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When the object is sent to and from the ractor, it is important to understand whether the object is shareable or unshareable. Most of objects are unshareable objects.</p>

<p>Shareable objects are basically those which can be used by several threads without compromising thread-safety; e.g. immutable ones. <a href="Ractor.html#method-c-shareable-3F"><code>Ractor.shareable?</code></a> allows to check this, and <a href="Ractor.html#method-c-make_shareable"><code>Ractor.make_shareable</code></a> tries to make object shareable if it is not.</p>

<pre class="ruby"><span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">shareable?</span>(<span class="ruby-value">1</span>)            <span class="ruby-comment">#=&gt; true -- numbers and other immutable basic values are</span>
<span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">shareable?</span>(<span class="ruby-string">&#39;foo&#39;</span>)        <span class="ruby-comment">#=&gt; false, unless the string is frozen due to # freeze_string_literals: true</span>
<span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">shareable?</span>(<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">freeze</span>) <span class="ruby-comment">#=&gt; true</span>

<span class="ruby-identifier">ary</span> = [<span class="ruby-string">&#39;hello&#39;</span>, <span class="ruby-string">&#39;world&#39;</span>]
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">frozen?</span>                 <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-identifier">ary</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">frozen?</span>              <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">make_shareable</span>(<span class="ruby-identifier">ary</span>)
<span class="ruby-identifier">ary</span>.<span class="ruby-identifier">frozen?</span>                 <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">ary</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">frozen?</span>              <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">ary</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">frozen?</span>              <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>When a shareable object is sent (via send or <a href="Ractor.html#method-c-yield"><code>Ractor.yield</code></a>), no additional processing happens, and it just becomes usable by both ractors. When an unshareable object is sent, it can be either <em>copied</em> or <em>moved</em>. The first is the default, and it makes the object&#39;s full copy by deep cloning of non-shareable parts of its structure.</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>.<span class="ruby-identifier">freeze</span>]
<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">data2</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">receive</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;In ractor: #{data2.object_id}, #{data2[0].object_id}, #{data2[1].object_id}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">data</span>)
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Outside  : #{data.object_id}, #{data[0].object_id}, #{data[1].object_id}&quot;</span>
</pre>

<p>This will output:</p>

<pre>In ractor: 340, 360, 320
Outside  : 380, 400, 320</pre>

<p>(Note that object id of both array and non-frozen string inside array have changed inside the ractor, showing it is different objects. But the second array&#39;s element, which is a shareable frozen string, has the same object_id.)</p>

<p>Deep cloning of the objects may be slow, and sometimes impossible. Alternatively, <code>move: true</code> may be used on sending. This will <em>move</em> the object to the receiving ractor, making it inaccessible for a sending ractor.</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = [<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-string">&#39;bar&#39;</span>]
<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">data_in_ractor</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">receive</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;In ractor: #{data_in_ractor.object_id}, #{data_in_ractor[0].object_id}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">data</span>, <span class="ruby-value">move:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Outside: moved? #{Ractor::MovedObject === data}&quot;</span>
<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Outside: #{data.inspect}&quot;</span>
</pre>

<p>This will output:</p>

<pre>In ractor: 100, 120
Outside: moved? true
test.rb:9:in `method_missing&#39;: can not send any methods to a moved object (Ractor::MovedError)</pre>

<p>Notice that even <code>inspect</code> (and more basic methods like <code>__id__</code>) is inaccessible on a moved object.</p>

<p>Besides frozen objects, there are shareable objects. <a href="Class.html"><code>Class</code></a> and <a href="Module.html"><code>Module</code></a> objects are shareable so the Class/Module definitions are shared between ractors. <a href="Ractor.html"><code>Ractor</code></a> objects are also shareable objects. All operations for the shareable mutable objects are thread-safe, so the thread-safety property will be kept. We can not define mutable shareable objects in Ruby, but C extensions can introduce them.</p>

<p>It is prohibited to access instance variables of mutable shareable objects (especially Modules and classes) from ractors other than main:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">C</span>
  <span class="ruby-keyword">class</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-keyword">self</span>
    <span class="ruby-identifier">attr_accessor</span> <span class="ruby-value">:tricky</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-constant">C</span>.<span class="ruby-identifier">tricky</span> = <span class="ruby-string">&#39;test&#39;</span>

<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span>(<span class="ruby-constant">C</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">cls</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I see #{cls}&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I can&#39;t see #{cls.tricky}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># I see C</span>
<span class="ruby-comment"># can not access instance variables of classes/modules from non-main Ractors (RuntimeError)</span>
</pre>

<p>Ractors can access constants if they are shareable. The main <a href="Ractor.html"><code>Ractor</code></a> is the only one that can access non-shareable constants.</p>

<pre class="ruby"><span class="ruby-constant">GOOD</span> = <span class="ruby-string">&#39;good&#39;</span>.<span class="ruby-identifier">freeze</span>
<span class="ruby-constant">BAD</span> = <span class="ruby-string">&#39;bad&#39;</span>

<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;GOOD=#{GOOD}&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;BAD=#{BAD}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># GOOD=good</span>
<span class="ruby-comment"># can not access non-shareable objects in constant Object::BAD by non-main Ractor. (NameError)</span>

<span class="ruby-comment"># Consider the same C class from above</span>

<span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I see #{C}&quot;</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;I can&#39;t see #{C.tricky}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># I see C</span>
<span class="ruby-comment"># can not access instance variables of classes/modules from non-main Ractors (RuntimeError)</span>
</pre>

<p>See also the description of <code># shareable_constant_value</code> pragma in Comments syntax explanation.</p>

<h2 id="label-Ractors+vs+threads">Ractors vs threads<span><a href="#label-Ractors+vs+threads">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Each ractor creates its own thread. New threads can be created from inside ractor (and, on CRuby, sharing GVL with other threads of this ractor).</p>

<pre class="ruby"><span class="ruby-identifier">r</span> = <span class="ruby-constant">Ractor</span>.<span class="ruby-identifier">new</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">a</span> = <span class="ruby-value">1</span>
  <span class="ruby-constant">Thread</span>.<span class="ruby-identifier">new</span> {<span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;Thread in ractor: a=#{a}&quot;</span>}.<span class="ruby-identifier">join</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">r</span>.<span class="ruby-identifier">take</span>
<span class="ruby-comment"># Here &quot;Thread in ractor: a=1&quot; will be printed</span>
</pre>

<h2 id="label-Note+on+code+examples">Note on code examples<span><a href="#label-Note+on+code+examples">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In examples below, sometimes we use the following method to wait till ractors that are not currently blocked will finish (or process till next blocking) method.</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">wait</span>
  <span class="ruby-identifier">sleep</span>(<span class="ruby-value">0.1</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>It is **only for demonstration purposes** and shouldn&#39;t be used in a real code. Most of the times, just take is used to wait till ractor will finish.</p>

<h2 id="label-Reference">Reference<span><a href="#label-Reference">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>See Ractor design doc for more details.</p>

		</div>
		
  </div>


 <!-- JavaScript at the bottom for fast page loading -->

  <!-- Grab Google CDN's jQuery, with a protocol relative URL; fall back to local if offline -->
            <script src="./js/libs/jquery-1.6.2.min.js"></script>
            <!-- script src="//ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script -->
            <!-- script>window.jQuery || document.write('<script src="./js/libs/jquery-1.6.2.min.js"><\/script>')</script -->

	<script src="./js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
	<script src="./js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
	<script src="./js/rubydoc.js" type="text/javascript" charset="utf-8"></script>
  <script src="./js/libs/modernizr-2.0.6.min.js"></script>


  <script defer src="./js/plugins.js"></script>
  <script defer src="./js/script.js"></script>
  <!-- end scripts-->
<!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.
       chromium.org/developers/how-tos/chrome-frame-getting-started -->
  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->

  <div id='tx_fatal_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_fatal_versioned").load("/associated/3.1.2/fatal.ihtml");</script> <div id='tx_fatal' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_fatal").load("/associated/fatal.ihtml");</script> 
      
<div id="dsqus_thread"></div>

</div>
<div id="footer">
  
  <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is a service of <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>, purveyors of fine dance noise.  <div class='oio-inline'><ins data-revive-zoneid="1" data-revive-id="58924a5717c091dfee6dda3f7d38c4d7"></ins><script async src="//ras.ruby-doc.org/vvv/delivery/thesinkjs.php"></script></div></p>

    <p><small>Generated with Rubydoc Rdoc Generator 0.42.0</small>.</p>
  </div>
    </body>


</html>

